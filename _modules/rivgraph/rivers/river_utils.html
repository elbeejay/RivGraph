

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>rivgraph.rivers.river_utils &mdash; RivGraph 0.3 documentation</title>
  

  
  <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />

  
  
  
  

  
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../../../_static/jquery.js"></script>
        <script type="text/javascript" src="../../../_static/underscore.js"></script>
        <script type="text/javascript" src="../../../_static/doctools.js"></script>
        <script type="text/javascript" src="../../../_static/language_data.js"></script>
    
    <script type="text/javascript" src="../../../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../../index.html">
          

          
            
            <img src="../../../_static/logo.png" class="logo" alt="Logo"/>
          
          </a>

          
            
            
              <div class="version">
                0.3
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../quickstart/index.html">Quickstart</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../background/index.html">Background</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../install/index.html">Installation Instructions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../examples/index.html">Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../contributing/index.html">Contributing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../apiref/index.html">API Reference</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">RivGraph</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="../../index.html">Module code</a> &raquo;</li>
        
      <li>rivgraph.rivers.river_utils</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for rivgraph.rivers.river_utils</h1><div class="highlight"><pre>
<span></span><span class="c1"># -*- coding: utf-8 -*-</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">river_utils</span>
<span class="sd">===========</span>

<span class="sd">Created on Tue Nov  6 14:29:10 2018</span>

<span class="sd">@author: Jon</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">networkx</span> <span class="k">as</span> <span class="nn">nx</span>
<span class="kn">from</span> <span class="nn">fastdtw</span> <span class="kn">import</span> <span class="n">fastdtw</span>
<span class="kn">from</span> <span class="nn">scipy.ndimage.morphology</span> <span class="kn">import</span> <span class="n">distance_transform_edt</span>
<span class="kn">import</span> <span class="nn">shapely</span>
<span class="kn">from</span> <span class="nn">shapely.geometry</span> <span class="kn">import</span> <span class="n">LineString</span><span class="p">,</span> <span class="n">Polygon</span>
<span class="kn">import</span> <span class="nn">scipy.interpolate</span> <span class="k">as</span> <span class="nn">si</span>
<span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">signal</span>
<span class="kn">from</span> <span class="nn">scipy.spatial.distance</span> <span class="kn">import</span> <span class="n">cdist</span><span class="p">,</span> <span class="n">euclidean</span>
<span class="kn">from</span> <span class="nn">matplotlib</span> <span class="kn">import</span> <span class="n">pyplot</span> <span class="k">as</span> <span class="n">plt</span>
<span class="kn">import</span> <span class="nn">geopandas</span> <span class="k">as</span> <span class="nn">gpd</span>


<span class="kn">from</span> <span class="nn">rivgraph.ordered_set</span> <span class="kn">import</span> <span class="n">OrderedSet</span>
<span class="kn">import</span> <span class="nn">rivgraph.im_utils</span> <span class="k">as</span> <span class="nn">iu</span>
<span class="kn">import</span> <span class="nn">rivgraph.mask_to_graph</span> <span class="k">as</span> <span class="nn">m2g</span>
<span class="kn">import</span> <span class="nn">rivgraph.ln_utils</span> <span class="k">as</span> <span class="nn">lnu</span>


<div class="viewcode-block" id="prune_river"><a class="viewcode-back" href="../../../apiref/rivers.html#rivgraph.rivers.river_utils.prune_river">[docs]</a><span class="k">def</span> <span class="nf">prune_river</span><span class="p">(</span><span class="n">links</span><span class="p">,</span> <span class="n">nodes</span><span class="p">,</span> <span class="n">exit_sides</span><span class="p">,</span> <span class="n">Iskel</span><span class="p">,</span> <span class="n">gdobj</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Prune river network.&quot;&quot;&quot;</span>
    <span class="c1"># Get inlet nodes</span>
    <span class="n">nodes</span> <span class="o">=</span> <span class="n">find_inlet_outlet_nodes</span><span class="p">(</span><span class="n">links</span><span class="p">,</span> <span class="n">nodes</span><span class="p">,</span> <span class="n">exit_sides</span><span class="p">,</span> <span class="n">Iskel</span><span class="p">)</span>

    <span class="c1"># Remove spurs from network (this includes valid inlets and outlets unless</span>
    <span class="c1"># specified not to remove)</span>
    <span class="n">links</span><span class="p">,</span> <span class="n">nodes</span> <span class="o">=</span> <span class="n">lnu</span><span class="o">.</span><span class="n">remove_all_spurs</span><span class="p">(</span><span class="n">links</span><span class="p">,</span> <span class="n">nodes</span><span class="p">,</span>
                                        <span class="n">dontremove</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="n">nodes</span><span class="p">[</span><span class="s1">&#39;inlets&#39;</span><span class="p">]</span> <span class="o">+</span>
                                                        <span class="n">nodes</span><span class="p">[</span><span class="s1">&#39;outlets&#39;</span><span class="p">]))</span>

    <span class="c1"># # Add artificial nodes where necessary</span>
    <span class="c1"># links, nodes = lnu.add_artificial_nodes(links, nodes, gdobj)</span>
    <span class="n">links</span><span class="p">,</span> <span class="n">nodes</span> <span class="o">=</span> <span class="n">lnu</span><span class="o">.</span><span class="n">find_parallel_links</span><span class="p">(</span><span class="n">links</span><span class="p">,</span> <span class="n">nodes</span><span class="p">)</span>

    <span class="c1"># Remove sets of links that are disconnected from inlets/outlets except</span>
    <span class="c1"># for a single bridge link (effectively re-pruning the network)</span>
    <span class="n">links</span><span class="p">,</span> <span class="n">nodes</span> <span class="o">=</span> <span class="n">lnu</span><span class="o">.</span><span class="n">remove_disconnected_bridge_links</span><span class="p">(</span><span class="n">links</span><span class="p">,</span> <span class="n">nodes</span><span class="p">)</span>

    <span class="c1"># Remove one-pixel links</span>
    <span class="n">links</span><span class="p">,</span> <span class="n">nodes</span> <span class="o">=</span> <span class="n">lnu</span><span class="o">.</span><span class="n">remove_single_pixel_links</span><span class="p">(</span><span class="n">links</span><span class="p">,</span> <span class="n">nodes</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">links</span><span class="p">,</span> <span class="n">nodes</span></div>


<div class="viewcode-block" id="find_inlet_outlet_nodes"><a class="viewcode-back" href="../../../apiref/rivers.html#rivgraph.rivers.river_utils.find_inlet_outlet_nodes">[docs]</a><span class="k">def</span> <span class="nf">find_inlet_outlet_nodes</span><span class="p">(</span><span class="n">links</span><span class="p">,</span> <span class="n">nodes</span><span class="p">,</span> <span class="n">exit_sides</span><span class="p">,</span> <span class="n">Iskel</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Append inlet and outlet nodes to the node dictionary.</span>

<span class="sd">    Appends the inlet and outlet nodes to the nodes dictionary. Only works for</span>
<span class="sd">    rivers; deltas must be treated differently.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Find possible inlet/outlet link candidates as those attached to a node</span>
    <span class="c1"># of degree-1.</span>
    <span class="n">poss_endlinks</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">nconn</span> <span class="ow">in</span> <span class="n">nodes</span><span class="p">[</span><span class="s1">&#39;conn&#39;</span><span class="p">]:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">nconn</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">poss_endlinks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">nconn</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

    <span class="c1"># Find the row(s)/column(s) corresponding to extent of the river at the</span>
    <span class="c1"># exit sides</span>
    <span class="n">pixy</span><span class="p">,</span> <span class="n">pixx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">Iskel</span> <span class="o">==</span> <span class="kc">True</span><span class="p">)</span>
    <span class="n">e</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">pixx</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">pixx</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">pixy</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">pixy</span><span class="p">)</span>

    <span class="c1"># Get row, column coordinates of all nodes endpoints</span>
    <span class="n">n_r</span><span class="p">,</span> <span class="n">n_c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unravel_index</span><span class="p">(</span><span class="n">nodes</span><span class="p">[</span><span class="s1">&#39;idx&#39;</span><span class="p">],</span> <span class="n">Iskel</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

    <span class="c1"># Find inlets and outlets by searching for nodes that intersect the first</span>
    <span class="c1"># exit_side of the image</span>
    <span class="n">ins_outs</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]:</span>
        <span class="k">if</span> <span class="n">exit_sides</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;n&#39;</span><span class="p">:</span>
            <span class="n">idcs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">n_r</span> <span class="o">==</span> <span class="n">n</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">exit_sides</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;s&#39;</span><span class="p">:</span>
            <span class="n">idcs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">n_r</span> <span class="o">==</span> <span class="n">s</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">exit_sides</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;e&#39;</span><span class="p">:</span>
            <span class="n">idcs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">n_c</span> <span class="o">==</span> <span class="n">e</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">exit_sides</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;w&#39;</span><span class="p">:</span>
            <span class="n">idcs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">n_c</span> <span class="o">==</span> <span class="n">w</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

        <span class="n">ins_outs</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">nodes</span><span class="p">[</span><span class="s1">&#39;id&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">idcs</span><span class="p">])</span>

    <span class="c1"># If there were no inlet or outlet nodes found, take the possible</span>
    <span class="c1"># inlet/outlet that is closest to the corresponding exit side as the</span>
    <span class="c1"># inlet/outlet node</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ins_outs</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">exit_sides</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;n&#39;</span><span class="p">:</span>
            <span class="n">idcs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">n_r</span><span class="o">-</span><span class="n">n</span><span class="p">))</span>
        <span class="k">elif</span> <span class="n">exit_sides</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;s&#39;</span><span class="p">:</span>
            <span class="n">idcs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">n_r</span><span class="o">-</span><span class="n">s</span><span class="p">))</span>
        <span class="k">elif</span> <span class="n">exit_sides</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;e&#39;</span><span class="p">:</span>
            <span class="n">idcs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">n_c</span><span class="o">-</span><span class="n">e</span><span class="p">))</span>
        <span class="k">elif</span> <span class="n">exit_sides</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;w&#39;</span><span class="p">:</span>
            <span class="n">idcs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">n_c</span><span class="o">-</span><span class="n">w</span><span class="p">))</span>
        <span class="n">ins_outs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">nodes</span><span class="p">[</span><span class="s1">&#39;id&#39;</span><span class="p">][</span><span class="n">idcs</span><span class="p">]]</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ins_outs</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">exit_sides</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;n&#39;</span><span class="p">:</span>
            <span class="n">idcs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">n_r</span><span class="o">-</span><span class="n">n</span><span class="p">))</span>
        <span class="k">elif</span> <span class="n">exit_sides</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;s&#39;</span><span class="p">:</span>
            <span class="n">idcs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">n_r</span><span class="o">-</span><span class="n">s</span><span class="p">))</span>
        <span class="k">elif</span> <span class="n">exit_sides</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;e&#39;</span><span class="p">:</span>
            <span class="n">idcs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">n_c</span><span class="o">-</span><span class="n">e</span><span class="p">))</span>
        <span class="k">elif</span> <span class="n">exit_sides</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;w&#39;</span><span class="p">:</span>
            <span class="n">idcs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">n_c</span><span class="o">-</span><span class="n">w</span><span class="p">))</span>
        <span class="n">ins_outs</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">nodes</span><span class="p">[</span><span class="s1">&#39;id&#39;</span><span class="p">][</span><span class="n">idcs</span><span class="p">]]</span>

    <span class="c1"># Append inlets and outlets to nodes dictionary</span>
    <span class="n">nodes</span><span class="p">[</span><span class="s1">&#39;inlets&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ins_outs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">nodes</span><span class="p">[</span><span class="s1">&#39;outlets&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ins_outs</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">nodes</span><span class="p">[</span><span class="s1">&#39;inlets&#39;</span><span class="p">])</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;No inlet nodes found.&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">nodes</span><span class="p">[</span><span class="s1">&#39;outlets&#39;</span><span class="p">])</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;No outlet nodes found.&#39;</span><span class="p">)</span>

    <span class="c1"># TODO: handle special cases where the link intersects the edge of the</span>
    <span class="c1"># image but the node does not because the link is a loop. This might be</span>
    <span class="c1"># &quot;fixable&quot; by adjusting the padding multiplier; I don&#39;t have any test</span>
    <span class="c1"># cases to work on currently so leaving this unimplemented for now.</span>

    <span class="k">return</span> <span class="n">nodes</span></div>


<div class="viewcode-block" id="mask_to_centerline"><a class="viewcode-back" href="../../../apiref/rivers.html#rivgraph.rivers.river_utils.mask_to_centerline">[docs]</a><span class="k">def</span> <span class="nf">mask_to_centerline</span><span class="p">(</span><span class="n">Imask</span><span class="p">,</span> <span class="n">es</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Extract centerline from a river mask.</span>

<span class="sd">    This function takes an input binary mask of a river and extracts its</span>
<span class="sd">    centerline. If there are multiple channels (and therefore islands) in the</span>
<span class="sd">    river, they will be filled before the centerline is computed.</span>

<span class="sd">    .. note:: The input mask should have the following properties:</span>

<span class="sd">        1) There should be only one &quot;blob&quot; (connected component)</span>

<span class="sd">        2) Where the blob intersects the image edges, there should be only</span>
<span class="sd">           one channel. This avoids ambiguity in identifying inlet/outlet links</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    Imask : ndarray</span>
<span class="sd">        the mask image (numpy array)</span>
<span class="sd">    es : str</span>
<span class="sd">        two-character string comprinsed of &quot;n&quot;, &quot;e&quot;, &quot;s&quot;, or &quot;w&quot;. Exit sides</span>
<span class="sd">        correspond to the sides of the image that the river intersects.</span>
<span class="sd">        Upstream should be first, followed by downstream.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    dt.tif : geotiff</span>
<span class="sd">        geotiff of the distance transform of the binary mask</span>
<span class="sd">    skel.tif : geotiff</span>
<span class="sd">        geotiff of the skeletonized binary mask</span>
<span class="sd">    centerline.shp : shp</span>
<span class="sd">        shapefile of the centerline, arranged upstream to downstream</span>
<span class="sd">    cl.pkl : pkl</span>
<span class="sd">        pickle file containing centerline coords, EPSG, and paths dictionary</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Lowercase the exit sides</span>
    <span class="n">es</span> <span class="o">=</span> <span class="n">es</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>

    <span class="c1"># Keep only largest connected blob</span>
    <span class="n">I</span> <span class="o">=</span> <span class="n">iu</span><span class="o">.</span><span class="n">largest_blobs</span><span class="p">(</span><span class="n">Imask</span><span class="p">,</span> <span class="n">nlargest</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">action</span><span class="o">=</span><span class="s1">&#39;keep&#39;</span><span class="p">)</span>

    <span class="c1"># Fill holes in mask</span>
    <span class="n">Ihf</span> <span class="o">=</span> <span class="n">iu</span><span class="o">.</span><span class="n">fill_holes</span><span class="p">(</span><span class="n">I</span><span class="p">)</span>

    <span class="c1"># Skeletonize holes-filled river image</span>
    <span class="n">Ihf_skel</span> <span class="o">=</span> <span class="n">m2g</span><span class="o">.</span><span class="n">skeletonize_river_mask</span><span class="p">(</span><span class="n">Ihf</span><span class="p">,</span> <span class="n">es</span><span class="p">)</span>

    <span class="c1"># In some cases, skeleton spurs can prevent the creation of an endpoint</span>
    <span class="c1"># at the edge of the image. This next block of code tries to condition</span>
    <span class="c1"># the skeleton to prevent this from happening.</span>
    <span class="c1"># Find skeleton border pixels</span>
    <span class="n">skel_rows</span><span class="p">,</span> <span class="n">skel_cols</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">Ihf_skel</span><span class="p">)</span>
    <span class="n">idcs_top</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">skel_rows</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">idcs_bottom</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">skel_rows</span> <span class="o">==</span> <span class="n">Ihf_skel</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">idcs_right</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">skel_cols</span> <span class="o">==</span> <span class="n">Ihf_skel</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">idcs_left</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">skel_cols</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
    <span class="c1"># Remove skeleton border pixels</span>
    <span class="n">Ihf_skel</span><span class="p">[</span><span class="n">skel_rows</span><span class="p">[</span><span class="n">idcs_top</span><span class="p">],</span> <span class="n">skel_cols</span><span class="p">[</span><span class="n">idcs_top</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">Ihf_skel</span><span class="p">[</span><span class="n">skel_rows</span><span class="p">[</span><span class="n">idcs_bottom</span><span class="p">],</span> <span class="n">skel_cols</span><span class="p">[</span><span class="n">idcs_bottom</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">Ihf_skel</span><span class="p">[</span><span class="n">skel_rows</span><span class="p">[</span><span class="n">idcs_right</span><span class="p">],</span> <span class="n">skel_cols</span><span class="p">[</span><span class="n">idcs_right</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">Ihf_skel</span><span class="p">[</span><span class="n">skel_rows</span><span class="p">[</span><span class="n">idcs_left</span><span class="p">],</span> <span class="n">skel_cols</span><span class="p">[</span><span class="n">idcs_left</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="c1"># Remove all pixels now disconnected from the main skeleton</span>
    <span class="n">Ihf_skel</span> <span class="o">=</span> <span class="n">iu</span><span class="o">.</span><span class="n">largest_blobs</span><span class="p">(</span><span class="n">Ihf_skel</span><span class="p">,</span> <span class="n">nlargest</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">action</span><span class="o">=</span><span class="s1">&#39;keep&#39;</span><span class="p">)</span>
    <span class="c1"># Add the border pixels back</span>
    <span class="n">Ihf_skel</span><span class="p">[</span><span class="n">skel_rows</span><span class="p">[</span><span class="n">idcs_top</span><span class="p">],</span> <span class="n">skel_cols</span><span class="p">[</span><span class="n">idcs_top</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">Ihf_skel</span><span class="p">[</span><span class="n">skel_rows</span><span class="p">[</span><span class="n">idcs_bottom</span><span class="p">],</span> <span class="n">skel_cols</span><span class="p">[</span><span class="n">idcs_bottom</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">Ihf_skel</span><span class="p">[</span><span class="n">skel_rows</span><span class="p">[</span><span class="n">idcs_right</span><span class="p">],</span> <span class="n">skel_cols</span><span class="p">[</span><span class="n">idcs_right</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">Ihf_skel</span><span class="p">[</span><span class="n">skel_rows</span><span class="p">[</span><span class="n">idcs_left</span><span class="p">],</span> <span class="n">skel_cols</span><span class="p">[</span><span class="n">idcs_left</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">1</span>

    <span class="c1"># Keep only the largest connected skeleton</span>
    <span class="n">Ihf_skel</span> <span class="o">=</span> <span class="n">iu</span><span class="o">.</span><span class="n">largest_blobs</span><span class="p">(</span><span class="n">Ihf_skel</span><span class="p">,</span> <span class="n">nlargest</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">action</span><span class="o">=</span><span class="s1">&#39;keep&#39;</span><span class="p">)</span>

    <span class="c1"># Convert skeleton to graph</span>
    <span class="n">hf_links</span><span class="p">,</span> <span class="n">hf_nodes</span> <span class="o">=</span> <span class="n">m2g</span><span class="o">.</span><span class="n">skel_to_graph</span><span class="p">(</span><span class="n">Ihf_skel</span><span class="p">)</span>

    <span class="c1"># Compute holes-filled distance transform</span>
    <span class="n">Ihf_dist</span> <span class="o">=</span> <span class="n">distance_transform_edt</span><span class="p">(</span><span class="n">Ihf</span><span class="p">)</span>  <span class="c1"># distance transform</span>

    <span class="c1"># Append link widths and lengths</span>
    <span class="n">hf_links</span> <span class="o">=</span> <span class="n">lnu</span><span class="o">.</span><span class="n">link_widths_and_lengths</span><span class="p">(</span><span class="n">hf_links</span><span class="p">,</span> <span class="n">Ihf_dist</span><span class="p">)</span>

    <span class="sd">&quot;&quot;&quot; Find shortest path between inlet/outlet centerline nodes&quot;&quot;&quot;</span>
    <span class="c1"># Put skeleton into networkX graph object</span>
    <span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>
    <span class="n">G</span><span class="o">.</span><span class="n">add_nodes_from</span><span class="p">(</span><span class="n">hf_nodes</span><span class="p">[</span><span class="s1">&#39;id&#39;</span><span class="p">])</span>
    <span class="k">for</span> <span class="n">lc</span><span class="p">,</span> <span class="n">wt</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">hf_links</span><span class="p">[</span><span class="s1">&#39;conn&#39;</span><span class="p">],</span> <span class="n">hf_links</span><span class="p">[</span><span class="s1">&#39;len&#39;</span><span class="p">]):</span>
        <span class="n">G</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">lc</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">lc</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">weight</span><span class="o">=</span><span class="n">wt</span><span class="p">)</span>

    <span class="c1"># Get endpoints of graph</span>
    <span class="n">endpoints</span> <span class="o">=</span> <span class="p">[</span><span class="n">nid</span> <span class="k">for</span> <span class="n">nid</span><span class="p">,</span> <span class="n">nconn</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">hf_nodes</span><span class="p">[</span><span class="s1">&#39;id&#39;</span><span class="p">],</span> <span class="n">hf_nodes</span><span class="p">[</span><span class="s1">&#39;conn&#39;</span><span class="p">])</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">nconn</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">]</span>

    <span class="c1"># Filter endpoints if we have too many--shortest path compute time scales as a power of len(endpoints)</span>
    <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">endpoints</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">100</span><span class="p">:</span>
        <span class="n">ep_r</span><span class="p">,</span> <span class="n">ep_c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unravel_index</span><span class="p">([</span><span class="n">hf_nodes</span><span class="p">[</span><span class="s1">&#39;idx&#39;</span><span class="p">][</span><span class="n">hf_nodes</span><span class="p">[</span><span class="s1">&#39;id&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">ep</span><span class="p">)]</span> <span class="k">for</span> <span class="n">ep</span> <span class="ow">in</span> <span class="n">endpoints</span><span class="p">],</span> <span class="n">Ihf_skel</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="n">pct</span> <span class="o">=</span> <span class="mi">10</span>
        <span class="n">ep_keep</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">esi</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">es</span><span class="p">[</span><span class="n">esi</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;n&#39;</span><span class="p">:</span>
                <span class="n">n_pct</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">ep_r</span><span class="p">,</span> <span class="n">pct</span><span class="p">))</span>
                <span class="n">ep_keep</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">ep_r</span> <span class="o">&lt;=</span> <span class="n">n_pct</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span>
            <span class="k">elif</span> <span class="n">es</span><span class="p">[</span><span class="n">esi</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;s&#39;</span><span class="p">:</span>
                <span class="n">s_pct</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">ep_r</span><span class="p">,</span> <span class="mi">100</span><span class="o">-</span><span class="n">pct</span><span class="p">))</span>
                <span class="n">ep_keep</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">ep_r</span> <span class="o">&gt;=</span> <span class="n">s_pct</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span>
            <span class="k">elif</span> <span class="n">es</span><span class="p">[</span><span class="n">esi</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;e&#39;</span><span class="p">:</span>
                <span class="n">e_pct</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">ep_c</span><span class="p">,</span> <span class="mi">100</span><span class="o">-</span><span class="n">pct</span><span class="p">))</span>
                <span class="n">ep_keep</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">ep_c</span> <span class="o">&gt;</span> <span class="n">e_pct</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span>
            <span class="k">elif</span> <span class="n">es</span><span class="p">[</span><span class="n">esi</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;w&#39;</span><span class="p">:</span>
                <span class="n">w_pct</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">ep_c</span><span class="p">,</span> <span class="n">pct</span><span class="p">))</span>
                <span class="n">ep_keep</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">ep_c</span> <span class="o">&lt;</span> <span class="n">w_pct</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span>

        <span class="n">endpoints</span> <span class="o">=</span> <span class="p">[</span><span class="n">endpoints</span><span class="p">[</span><span class="n">ek</span><span class="p">]</span> <span class="k">for</span> <span class="n">ek</span> <span class="ow">in</span> <span class="n">ep_keep</span><span class="p">]</span>

    <span class="c1"># Get all paths from inlet(s) to outlets</span>
    <span class="n">longest_shortest_paths</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">inl</span> <span class="ow">in</span> <span class="n">endpoints</span><span class="p">:</span>
        <span class="n">temp_lens</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">endpoints</span><span class="p">:</span>
            <span class="n">temp_lens</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">nx</span><span class="o">.</span><span class="n">dijkstra_path_length</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">inl</span><span class="p">,</span> <span class="n">o</span><span class="p">,</span>
                                                     <span class="n">weight</span><span class="o">=</span><span class="s1">&#39;weight&#39;</span><span class="p">))</span>
        <span class="n">longest_shortest_paths</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">temp_lens</span><span class="p">))</span>

    <span class="c1"># The two end nodes with the longest shortest path are the centerline&#39;s</span>
    <span class="c1"># endnodes</span>
    <span class="n">end_nodes_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">longest_shortest_paths</span><span class="p">),</span>
                                        <span class="n">longest_shortest_paths</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">end_nodes</span> <span class="o">=</span> <span class="p">[</span><span class="n">endpoints</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">end_nodes_idx</span><span class="p">]</span>

    <span class="c1"># It is possible that more than two endnodes were identified; in these</span>
    <span class="c1"># cases, choose the nodes that are farthest apart in Euclidean space</span>
    <span class="n">en_r</span><span class="p">,</span> <span class="n">en_c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unravel_index</span><span class="p">([</span><span class="n">hf_nodes</span><span class="p">[</span><span class="s1">&#39;idx&#39;</span><span class="p">][</span><span class="n">hf_nodes</span><span class="p">[</span><span class="s1">&#39;id&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">en</span><span class="p">)]</span> <span class="k">for</span> <span class="n">en</span> <span class="ow">in</span> <span class="n">end_nodes</span><span class="p">],</span> <span class="n">Ihf_skel</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">ep_coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="s1">&#39;1,2,0&#39;</span><span class="p">,</span> <span class="n">en_r</span><span class="p">,</span> <span class="n">en_c</span><span class="p">]</span>
    <span class="n">ep_dists</span> <span class="o">=</span> <span class="n">cdist</span><span class="p">(</span><span class="n">ep_coords</span><span class="p">,</span> <span class="n">ep_coords</span><span class="p">,</span> <span class="s1">&#39;euclidean&#39;</span><span class="p">)</span>
    <span class="n">en_idcs_to_use</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unravel_index</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">ep_dists</span><span class="p">),</span> <span class="n">ep_dists</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">end_nodes</span> <span class="o">=</span> <span class="p">[</span><span class="n">end_nodes</span><span class="p">[</span><span class="n">eitu</span><span class="p">]</span> <span class="k">for</span> <span class="n">eitu</span> <span class="ow">in</span> <span class="n">en_idcs_to_use</span><span class="p">]</span>

    <span class="c1"># Ensure that exactly two end nodes are identified</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">end_nodes</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1"> endpoints were found for the centerline. (Need exactly two).&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">end_nodes</span><span class="p">)))</span>

    <span class="c1"># Find upstream node</span>
    <span class="n">en_r</span><span class="p">,</span> <span class="n">en_c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unravel_index</span><span class="p">([</span><span class="n">hf_nodes</span><span class="p">[</span><span class="s1">&#39;idx&#39;</span><span class="p">][</span><span class="n">hf_nodes</span><span class="p">[</span><span class="s1">&#39;id&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">n</span><span class="p">)]</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">end_nodes</span><span class="p">],</span> <span class="n">Ihf_skel</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

    <span class="c1"># Compute error for each end node given the exit sides</span>
    <span class="n">errors</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">orientation</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]:</span>
        <span class="k">if</span> <span class="n">orientation</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">er</span> <span class="o">=</span> <span class="n">en_r</span>
            <span class="n">ec</span> <span class="o">=</span> <span class="n">en_c</span>
        <span class="k">elif</span> <span class="n">orientation</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">er</span> <span class="o">=</span> <span class="n">en_r</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">ec</span> <span class="o">=</span> <span class="n">en_c</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

        <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">ot</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">es</span><span class="p">[</span><span class="n">ot</span><span class="p">]</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;n&#39;</span><span class="p">:</span>
                <span class="n">err</span> <span class="o">=</span> <span class="n">err</span> <span class="o">+</span> <span class="n">er</span><span class="p">[</span><span class="n">ot</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">es</span><span class="p">[</span><span class="n">ot</span><span class="p">]</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;s&#39;</span><span class="p">:</span>
                <span class="n">err</span> <span class="o">=</span> <span class="n">err</span> <span class="o">+</span> <span class="n">Ihf_dist</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">er</span><span class="p">[</span><span class="n">ot</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">es</span><span class="p">[</span><span class="n">ot</span><span class="p">]</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;w&#39;</span><span class="p">:</span>
                <span class="n">err</span> <span class="o">=</span> <span class="n">err</span> <span class="o">+</span> <span class="n">ec</span><span class="p">[</span><span class="n">ot</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">es</span><span class="p">[</span><span class="n">ot</span><span class="p">]</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;e&#39;</span><span class="p">:</span>
                <span class="n">err</span> <span class="o">=</span> <span class="n">err</span> <span class="o">+</span> <span class="n">Ihf_dist</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">ec</span><span class="p">[</span><span class="n">ot</span><span class="p">]</span>
        <span class="n">errors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">err</span><span class="p">)</span>
    <span class="c1"># Flip end node orientation to get US-&gt;DS arrangement</span>
    <span class="k">if</span> <span class="n">errors</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">errors</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
        <span class="n">end_nodes</span> <span class="o">=</span> <span class="n">end_nodes</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

    <span class="c1"># Create centerline from links along shortest path</span>
    <span class="n">nodespath</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">dijkstra_path</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">end_nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">end_nodes</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>  <span class="c1"># nodes shortest path</span>
    <span class="c1"># Find the links along the shortest node path</span>
    <span class="n">cl_link_ids</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">nodespath</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">nodespath</span><span class="p">[</span><span class="mi">1</span><span class="p">:]):</span>
        <span class="n">ulinks</span> <span class="o">=</span> <span class="n">hf_nodes</span><span class="p">[</span><span class="s1">&#39;conn&#39;</span><span class="p">][</span><span class="n">hf_nodes</span><span class="p">[</span><span class="s1">&#39;id&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">u</span><span class="p">)]</span>
        <span class="n">vlinks</span> <span class="o">=</span> <span class="n">hf_nodes</span><span class="p">[</span><span class="s1">&#39;conn&#39;</span><span class="p">][</span><span class="n">hf_nodes</span><span class="p">[</span><span class="s1">&#39;id&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">v</span><span class="p">)]</span>
        <span class="n">cl_link_ids</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">ul</span> <span class="k">for</span> <span class="n">ul</span> <span class="ow">in</span> <span class="n">ulinks</span> <span class="k">if</span> <span class="n">ul</span> <span class="ow">in</span> <span class="n">vlinks</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>

    <span class="c1"># Create a shortest-path links dict</span>
    <span class="n">cl_links</span> <span class="o">=</span> <span class="nb">dict</span><span class="o">.</span><span class="n">fromkeys</span><span class="p">(</span><span class="n">hf_links</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
    <span class="n">dokeys</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">hf_links</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
    <span class="n">dokeys</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="s1">&#39;n_networks&#39;</span><span class="p">)</span>  <span class="c1"># Don&#39;t need n_networks</span>
    <span class="k">for</span> <span class="n">clid</span> <span class="ow">in</span> <span class="n">cl_link_ids</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">dokeys</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">cl_links</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">cl_links</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">cl_links</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">hf_links</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">hf_links</span><span class="p">[</span><span class="s1">&#39;id&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">clid</span><span class="p">)])</span>

    <span class="c1"># Save centerline as shapefile</span>
<span class="c1">#    lnu.links_to_shapefile(cl_links, igd, rmh.get_EPSG(paths[&#39;skel&#39;]), paths[&#39;cl_temp_shp&#39;])</span>

    <span class="c1"># Get and save coordinates of centerline</span>
    <span class="n">cl</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">ic</span><span class="p">,</span> <span class="n">cll</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">cl_link_ids</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">ic</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">hf_links</span><span class="p">[</span><span class="s1">&#39;idx&#39;</span><span class="p">][</span><span class="n">hf_links</span><span class="p">[</span><span class="s1">&#39;id&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">cll</span><span class="p">)][</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">hf_nodes</span><span class="p">[</span><span class="s1">&#39;idx&#39;</span><span class="p">][</span><span class="n">hf_nodes</span><span class="p">[</span><span class="s1">&#39;id&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">end_nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">])]:</span>
                <span class="n">hf_links</span><span class="p">[</span><span class="s1">&#39;idx&#39;</span><span class="p">][</span><span class="n">hf_links</span><span class="p">[</span><span class="s1">&#39;id&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">cll</span><span class="p">)]</span> <span class="o">=</span> <span class="n">hf_links</span><span class="p">[</span><span class="s1">&#39;idx&#39;</span><span class="p">][</span><span class="n">hf_links</span><span class="p">[</span><span class="s1">&#39;id&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">cll</span><span class="p">)][::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">hf_links</span><span class="p">[</span><span class="s1">&#39;idx&#39;</span><span class="p">][</span><span class="n">hf_links</span><span class="p">[</span><span class="s1">&#39;id&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">cll</span><span class="p">)][</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">cl</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
                <span class="n">hf_links</span><span class="p">[</span><span class="s1">&#39;idx&#39;</span><span class="p">][</span><span class="n">hf_links</span><span class="p">[</span><span class="s1">&#39;id&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">cll</span><span class="p">)]</span> <span class="o">=</span> <span class="n">hf_links</span><span class="p">[</span><span class="s1">&#39;idx&#39;</span><span class="p">][</span><span class="n">hf_links</span><span class="p">[</span><span class="s1">&#39;id&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">cll</span><span class="p">)][::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

        <span class="n">cl</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">hf_links</span><span class="p">[</span><span class="s1">&#39;idx&#39;</span><span class="p">][</span><span class="n">hf_links</span><span class="p">[</span><span class="s1">&#39;id&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">cll</span><span class="p">)][:])</span>

    <span class="c1"># Uniquify points, preserving order</span>
    <span class="n">cl</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">OrderedSet</span><span class="p">(</span><span class="n">cl</span><span class="p">))</span>

    <span class="c1"># Convert back to coordinates</span>
    <span class="n">cly</span><span class="p">,</span> <span class="n">clx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unravel_index</span><span class="p">(</span><span class="n">cl</span><span class="p">,</span> <span class="n">Ihf_skel</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

    <span class="c1"># Get width at each pixel of centerline</span>
    <span class="n">pix_width</span> <span class="o">=</span> <span class="p">[</span><span class="n">Ihf_dist</span><span class="p">[</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">]</span><span class="o">*</span><span class="mi">2</span> <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">clx</span><span class="p">,</span> <span class="n">cly</span><span class="p">)]</span>

    <span class="n">coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">clx</span><span class="p">,</span> <span class="n">cly</span><span class="p">)))</span>

    <span class="k">return</span> <span class="n">coords</span><span class="p">,</span> <span class="n">pix_width</span></div>


<div class="viewcode-block" id="resample_line"><a class="viewcode-back" href="../../../apiref/rivers.html#rivgraph.rivers.river_utils.resample_line">[docs]</a><span class="k">def</span> <span class="nf">resample_line</span><span class="p">(</span><span class="n">xs</span><span class="p">,</span> <span class="n">ys</span><span class="p">,</span> <span class="n">npts</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">nknots</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">3</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Resample a line.</span>

<span class="sd">    Resamples a line defined by x,y coordinates such that coordinates are</span>
<span class="sd">    evenly-spaced.</span>
<span class="sd">    If the optional npts parameter is not specified, the</span>
<span class="sd">    line will be resampled with the same number of points as the input</span>
<span class="sd">    coordinates.</span>
<span class="sd">    k refers to order of spline that is fit to coordinates for resampling.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># FitPack in si.splprep can&#39;t handle duplicate points in the line, so remove them</span>
    <span class="n">no_dupes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">xs</span><span class="p">))</span> <span class="o">+</span>
                        <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">ys</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">)</span>
    <span class="n">xs_nd</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="n">xs</span><span class="p">[</span><span class="n">no_dupes</span><span class="p">],</span> <span class="n">xs</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span>
    <span class="n">ys_nd</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="n">ys</span><span class="p">[</span><span class="n">no_dupes</span><span class="p">],</span> <span class="n">ys</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span>

    <span class="c1"># Get indices of knots</span>
    <span class="k">if</span> <span class="n">nknots</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">nknots</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">xs_nd</span><span class="p">)</span>
    <span class="n">knot_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">xs_nd</span><span class="p">),</span> <span class="n">nknots</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">)</span>
    <span class="n">knot_indices</span><span class="p">[</span><span class="n">knot_indices</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">xs_nd</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">xs_nd</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="n">knot_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">knot_indices</span><span class="p">)</span>

    <span class="c1"># Create spline</span>
    <span class="n">spline</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">si</span><span class="o">.</span><span class="n">splprep</span><span class="p">([</span><span class="n">xs_nd</span><span class="p">[</span><span class="n">knot_indices</span><span class="p">],</span> <span class="n">ys_nd</span><span class="p">[</span><span class="n">knot_indices</span><span class="p">]],</span> <span class="n">k</span><span class="o">=</span><span class="n">k</span><span class="p">)</span>

    <span class="c1"># Evaluate spline</span>
    <span class="k">if</span> <span class="n">npts</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">npts</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">xs</span><span class="p">)</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">npts</span><span class="p">)</span>
    <span class="n">resampled_coords</span> <span class="o">=</span> <span class="n">si</span><span class="o">.</span><span class="n">splev</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">spline</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">resampled_coords</span><span class="p">,</span> <span class="n">spline</span></div>


<div class="viewcode-block" id="evenly_space_line"><a class="viewcode-back" href="../../../apiref/rivers.html#rivgraph.rivers.river_utils.evenly_space_line">[docs]</a><span class="k">def</span> <span class="nf">evenly_space_line</span><span class="p">(</span><span class="n">xs</span><span class="p">,</span> <span class="n">ys</span><span class="p">,</span> <span class="n">npts</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Resample evenly.</span>

<span class="sd">    Resamples a curve defined by x,y coordinates such that coordinates are</span>
<span class="sd">    evenly-spaced.</span>
<span class="sd">    If the optional npts parameter is not specified, the</span>
<span class="sd">    line will be resampled with the same number of points as the input</span>
<span class="sd">    coordinates.</span>
<span class="sd">    k refers to order of spline that is fit to coordinates for resampling.</span>
<span class="sd">    xs, ys must be numpy arrays.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># FitPack in si.splprep can&#39;t handle duplicate points in the line, so remove them</span>
    <span class="n">shapely_line</span> <span class="o">=</span> <span class="n">LineString</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">xs</span><span class="p">,</span> <span class="n">ys</span><span class="p">))</span>
    <span class="n">shapely_line</span> <span class="o">=</span> <span class="n">shapely_line</span><span class="o">.</span><span class="n">simplify</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">xs_nd</span><span class="p">,</span> <span class="n">ys_nd</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">shapely_line</span><span class="o">.</span><span class="n">coords</span><span class="o">.</span><span class="n">xy</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">shapely_line</span><span class="o">.</span><span class="n">coords</span><span class="o">.</span><span class="n">xy</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

    <span class="c1"># Create spline</span>
    <span class="n">spline</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">si</span><span class="o">.</span><span class="n">splprep</span><span class="p">([</span><span class="n">xs_nd</span><span class="p">,</span> <span class="n">ys_nd</span><span class="p">],</span> <span class="n">k</span><span class="o">=</span><span class="n">k</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="n">s</span><span class="p">)</span>

    <span class="c1"># Evaluate spline</span>
    <span class="k">if</span> <span class="n">npts</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">npts</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">xs</span><span class="p">)</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">npts</span><span class="p">)</span>
    <span class="n">resampled_coords</span> <span class="o">=</span> <span class="n">si</span><span class="o">.</span><span class="n">splev</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">spline</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">resampled_coords</span><span class="p">,</span> <span class="n">spline</span></div>


<div class="viewcode-block" id="offset_linestring"><a class="viewcode-back" href="../../../apiref/rivers.html#rivgraph.rivers.river_utils.offset_linestring">[docs]</a><span class="k">def</span> <span class="nf">offset_linestring</span><span class="p">(</span><span class="n">linestring</span><span class="p">,</span> <span class="n">distance</span><span class="p">,</span> <span class="n">side</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Offset a linestring.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    linestring :</span>
<span class="sd">        shapely linestring</span>
<span class="sd">    distance :</span>
<span class="sd">        distance to offset linestring</span>
<span class="sd">    side :</span>
<span class="sd">        &#39;left&#39; or &#39;right&#39; to specify which side to compute offset</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Perform the offset</span>
    <span class="n">offset</span> <span class="o">=</span> <span class="n">linestring</span><span class="o">.</span><span class="n">parallel_offset</span><span class="p">(</span><span class="n">distance</span><span class="p">,</span> <span class="n">side</span><span class="p">)</span>

    <span class="c1"># Ensure that offset is not a MultiLineString by deleting all but the longest linestring</span>
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">offset</span><span class="p">)</span> <span class="ow">is</span> <span class="n">shapely</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">multilinestring</span><span class="o">.</span><span class="n">MultiLineString</span><span class="p">:</span>
        <span class="n">ls_lengths</span> <span class="o">=</span> <span class="p">[</span><span class="n">ls</span><span class="o">.</span><span class="n">length</span> <span class="k">for</span> <span class="n">ls</span> <span class="ow">in</span> <span class="n">offset</span><span class="p">]</span>
        <span class="n">offset</span> <span class="o">=</span> <span class="n">offset</span><span class="p">[</span><span class="n">ls_lengths</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">ls_lengths</span><span class="p">))]</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Multilinestring returned in offset_linestring; clipped to longest but check output.&#39;</span><span class="p">)</span>

    <span class="c1"># Ensure offset linestring is oriented the same as the input linestring</span>
    <span class="n">xy_orig_start</span> <span class="o">=</span> <span class="p">(</span><span class="n">linestring</span><span class="o">.</span><span class="n">coords</span><span class="o">.</span><span class="n">xy</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">linestring</span><span class="o">.</span><span class="n">coords</span><span class="o">.</span><span class="n">xy</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>

    <span class="c1"># Get endpoint coordinates of offset linestring</span>
    <span class="n">xy_offset_start</span> <span class="o">=</span> <span class="p">(</span><span class="n">offset</span><span class="o">.</span><span class="n">coords</span><span class="o">.</span><span class="n">xy</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">offset</span><span class="o">.</span><span class="n">coords</span><span class="o">.</span><span class="n">xy</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">xy_offset_end</span> <span class="o">=</span> <span class="p">(</span><span class="n">offset</span><span class="o">.</span><span class="n">coords</span><span class="o">.</span><span class="n">xy</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">offset</span><span class="o">.</span><span class="n">coords</span><span class="o">.</span><span class="n">xy</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">xy_orig_start</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">xy_offset_start</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span>
                      <span class="p">(</span><span class="n">xy_orig_start</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">xy_offset_start</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span> <span class="o">&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">xy_orig_start</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">xy_offset_end</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">xy_orig_start</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">xy_offset_end</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span><span class="p">)):</span>
        <span class="n">offset</span> <span class="o">=</span> <span class="n">LineString</span><span class="p">(</span><span class="n">offset</span><span class="o">.</span><span class="n">coords</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

    <span class="k">return</span> <span class="n">offset</span></div>


<div class="viewcode-block" id="inflection_pts_oversmooth"><a class="viewcode-back" href="../../../apiref/rivers.html#rivgraph.rivers.river_utils.inflection_pts_oversmooth">[docs]</a><span class="k">def</span> <span class="nf">inflection_pts_oversmooth</span><span class="p">(</span><span class="n">xs</span><span class="p">,</span> <span class="n">ys</span><span class="p">,</span> <span class="n">n_infs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute inflection points.</span>

<span class="sd">    Computes inflection points as the intersection of a line given by</span>
<span class="sd">    xs, ys and its (over)smoothed version.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    xs :</span>
<span class="sd">        np-type array of x-coordinates</span>
<span class="sd">    ys :</span>
<span class="sd">        np-type array of y-coordinates</span>
<span class="sd">    n_infs :</span>
<span class="sd">        approx how many inflection points are expected? This sets the</span>
<span class="sd">        degree of smoothing. For meandering rivers, n_infs can be</span>
<span class="sd">        approximated by the relationship: wavelength = 10W, for average</span>
<span class="sd">        width W.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">generate_smoothing_windows</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">nbreaks</span><span class="p">,</span> <span class="n">polyorder</span><span class="o">=</span><span class="mi">3</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generate smoothing window sizes.</span>

<span class="sd">        Generate an array of window sizes for smoothing. Each value must be</span>
<span class="sd">        greater than the polyorder of the smoother and be odd.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">smoothwins</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">nbreaks</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">)</span>

        <span class="c1"># Window must be greater than polyorder</span>
        <span class="n">smoothwins</span><span class="p">[</span><span class="n">smoothwins</span> <span class="o">&lt;</span> <span class="n">polyorder</span><span class="p">]</span> <span class="o">=</span> <span class="n">polyorder</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="c1"># Window must be odd</span>
        <span class="n">smoothwins</span><span class="p">[</span><span class="n">smoothwins</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">smoothwins</span><span class="p">[</span><span class="n">smoothwins</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">smoothwins</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">smoothwins</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">smoothwins</span>

    <span class="k">def</span> <span class="nf">smoothing_iterator</span><span class="p">(</span><span class="n">xs</span><span class="p">,</span> <span class="n">ys</span><span class="p">,</span> <span class="n">smoothing_windows</span><span class="p">,</span> <span class="n">n_infs</span><span class="p">,</span> <span class="n">polyorder</span><span class="p">):</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">sw</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">smoothing_windows</span><span class="p">):</span>

            <span class="c1"># Smooth the line&#39;s coordinates</span>
            <span class="n">xs_sm</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">savgol_filter</span><span class="p">(</span><span class="n">xs</span><span class="p">,</span> <span class="n">window_length</span><span class="o">=</span><span class="n">sw</span><span class="p">,</span>
                                         <span class="n">polyorder</span><span class="o">=</span><span class="n">polyorder</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;interp&#39;</span><span class="p">)</span>
            <span class="n">ys_sm</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">savgol_filter</span><span class="p">(</span><span class="n">ys</span><span class="p">,</span> <span class="n">window_length</span><span class="o">=</span><span class="n">sw</span><span class="p">,</span>
                                         <span class="n">polyorder</span><span class="o">=</span><span class="n">polyorder</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;interp&#39;</span><span class="p">)</span>

            <span class="c1"># Conver to shapely objects for intersection detection</span>
            <span class="n">ls</span> <span class="o">=</span> <span class="n">LineString</span><span class="p">([(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">xs</span><span class="p">,</span> <span class="n">ys</span><span class="p">)])</span>
            <span class="n">ls_sm</span> <span class="o">=</span> <span class="n">LineString</span><span class="p">([(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">xs_sm</span><span class="p">,</span> <span class="n">ys_sm</span><span class="p">)])</span>

            <span class="n">intersects</span> <span class="o">=</span> <span class="n">ls</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">ls_sm</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">intersects</span><span class="p">)</span> <span class="ow">is</span> <span class="n">shapely</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">point</span><span class="o">.</span><span class="n">Point</span><span class="p">:</span>  <span class="c1"># Points have no length so check</span>
                <span class="n">n_ints</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">n_ints</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">ls</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">ls_sm</span><span class="p">))</span>

            <span class="k">if</span> <span class="n">n_ints</span> <span class="o">&lt;</span> <span class="n">n_infs</span><span class="p">:</span>
                <span class="k">break</span>

        <span class="k">return</span> <span class="n">smoothing_windows</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">smoothing_windows</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

    <span class="c1"># Set polyorder for smoother; could be included as a parameter</span>
    <span class="n">polyorder</span> <span class="o">=</span> <span class="mi">3</span>

    <span class="c1"># Find the smoothing window that provides a number of intersections closest</span>
    <span class="c1"># to the provided n_infs</span>
    <span class="n">prepost_tolerance</span> <span class="o">=</span> <span class="mi">10</span>  <span class="c1"># difference between smoothing window sizes to stop iterating</span>
    <span class="n">prev</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># initial minimum smoothing window size</span>
    <span class="n">post</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">xs</span><span class="p">)</span><span class="o">/</span><span class="mi">5</span>  <span class="c1"># initial maximum smoothing window size</span>
    <span class="k">while</span> <span class="n">post</span> <span class="o">-</span> <span class="n">prev</span> <span class="o">&gt;</span> <span class="n">prepost_tolerance</span><span class="p">:</span>
        <span class="n">s_windows</span> <span class="o">=</span> <span class="n">generate_smoothing_windows</span><span class="p">(</span><span class="n">prev</span><span class="p">,</span> <span class="n">post</span><span class="p">,</span> <span class="mi">25</span><span class="p">,</span> <span class="n">polyorder</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
        <span class="n">prev</span><span class="p">,</span> <span class="n">post</span> <span class="o">=</span> <span class="n">smoothing_iterator</span><span class="p">(</span><span class="n">xs</span><span class="p">,</span> <span class="n">ys</span><span class="p">,</span> <span class="n">s_windows</span><span class="p">,</span> <span class="n">n_infs</span><span class="p">,</span> <span class="n">polyorder</span><span class="p">)</span>

        <span class="c1">## TODO: should add a counter/tracker to ensure n_infs can actually be</span>
        <span class="c1"># obtained and avoid an infinite loop</span>

    <span class="c1"># Use the optimized smoothing window to smooth the signal</span>
    <span class="n">window</span> <span class="o">=</span> <span class="n">post</span>
    <span class="n">xs_sm</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">savgol_filter</span><span class="p">(</span><span class="n">xs</span><span class="p">,</span> <span class="n">window_length</span><span class="o">=</span><span class="n">window</span><span class="p">,</span> <span class="n">polyorder</span><span class="o">=</span><span class="n">polyorder</span><span class="p">,</span>
                                 <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;interp&#39;</span><span class="p">)</span>
    <span class="n">ys_sm</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">savgol_filter</span><span class="p">(</span><span class="n">ys</span><span class="p">,</span> <span class="n">window_length</span><span class="o">=</span><span class="n">window</span><span class="p">,</span> <span class="n">polyorder</span><span class="o">=</span><span class="n">polyorder</span><span class="p">,</span>
                                 <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;interp&#39;</span><span class="p">)</span>

    <span class="c1"># Cast coordinates as shapely LineString objects</span>
    <span class="n">ls</span> <span class="o">=</span> <span class="n">LineString</span><span class="p">([(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">xs</span><span class="p">,</span> <span class="n">ys</span><span class="p">)])</span>
    <span class="n">ls_sm</span> <span class="o">=</span> <span class="n">LineString</span><span class="p">([(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">xs_sm</span><span class="p">,</span> <span class="n">ys_sm</span><span class="p">)])</span>

    <span class="c1"># Compute intersection points between original and oversmoothed centerline</span>
    <span class="n">int_pts</span> <span class="o">=</span> <span class="n">ls</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">ls_sm</span><span class="p">)</span>
    <span class="n">int_coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([(</span><span class="n">int_pts</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">coords</span><span class="o">.</span><span class="n">xy</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span>
                            <span class="n">int_pts</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">coords</span><span class="o">.</span><span class="n">xy</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">int_pts</span><span class="p">))])</span>

    <span class="c1"># Map the intersecting coordinates to the indices of the original signal</span>
    <span class="n">idx</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">ic</span> <span class="ow">in</span> <span class="n">int_coords</span><span class="p">:</span>
        <span class="n">idx</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">ic</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">xs</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="p">(</span><span class="n">ic</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">ys</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)))</span>
    <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>

<span class="c1">#    plt.close(&#39;all&#39;)</span>
<span class="c1">#    plt.plot(xs_sm,ys_sm)</span>
<span class="c1">#    plt.plot(xs,ys)</span>
<span class="c1">#    plt.plot(xs[idx], ys[idx], &#39;.&#39;)</span>
<span class="c1">#    plt.axis(&#39;equal&#39;)</span>

    <span class="c1"># Package oversmoothed coordinates for export</span>
    <span class="n">smoothline</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">xs_sm</span><span class="p">,</span> <span class="n">ys_sm</span><span class="p">])</span>

    <span class="k">return</span> <span class="n">idx</span><span class="p">,</span> <span class="n">smoothline</span></div>


<div class="viewcode-block" id="centerline_mesh"><a class="viewcode-back" href="../../../apiref/rivers.html#rivgraph.rivers.river_utils.centerline_mesh">[docs]</a><span class="k">def</span> <span class="nf">centerline_mesh</span><span class="p">(</span><span class="n">coords</span><span class="p">,</span> <span class="n">width_chan</span><span class="p">,</span> <span class="n">meshwidth</span><span class="p">,</span> <span class="n">grid_spacing</span><span class="p">,</span> <span class="n">smoothing_param</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generate a centerline mesh.</span>

<span class="sd">    Generates a centerline mesh. Differs from :func:`valleyline_mesh` in that</span>
<span class="sd">    it draws perpendiculars rather than offsetting the valley line to compute</span>
<span class="sd">    mesh polygons. This method is more effective for narrower channels that</span>
<span class="sd">    don&#39;t require an exceptionally wide mesh (i.e. not much change).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    coords :</span>
<span class="sd">        2xN list, tuple, np.array (xs, ys) of coordinates defining centerline</span>
<span class="sd">    width_chan :</span>
<span class="sd">        width of the river in same units of coords</span>
<span class="sd">    mesh_dist :</span>
<span class="sd">        how wide should the mesh be, in same units of coords</span>
<span class="sd">    grid_spacing :</span>
<span class="sd">        how far apart should mesh cells be, in same units of coords</span>

<span class="sd">    &quot;&quot;&quot;</span>
<span class="c1">#    coords = ken.centerline</span>
<span class="c1">#    width_chan = ken.width_chans</span>
<span class="c1">#    meshwidth = ken.max_valley_width_pixels * ken.pixlen * 1.1</span>
<span class="c1">#    grid_spacing = meshwidth/10</span>
<span class="c1">#    smoothing_param = 1</span>

    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">coords</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">coords</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">4</span><span class="p">:</span>
        <span class="n">coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">coords</span><span class="p">)</span>

    <span class="c1"># Get lengths along centerline</span>
    <span class="n">s</span><span class="p">,</span> <span class="n">ds</span> <span class="o">=</span> <span class="n">s_ds</span><span class="p">(</span><span class="n">coords</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">coords</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">])</span>

    <span class="c1"># Mirror centerline manually since scipy fucks it up - only flip the axis that has the largest displacement</span>
    <span class="c1"># Mirroring done to avoid edge effects when smoothing</span>
    <span class="n">npad</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">width_chan</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">ds</span><span class="p">)</span> <span class="o">*</span> <span class="mi">10</span><span class="p">)</span>  <span class="c1"># Padding fixed at 10 channel widths</span>
    <span class="n">xs_m</span><span class="p">,</span> <span class="n">ys_m</span> <span class="o">=</span> <span class="n">mirror_line_ends</span><span class="p">(</span><span class="n">coords</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">coords</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">npad</span><span class="p">)</span>

    <span class="c1"># A smoothing filter of one-channel width will be passed over the centerline coordinates</span>
    <span class="n">window_len</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">width_chan</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">ds</span><span class="p">)</span> <span class="o">*</span> <span class="n">smoothing_param</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">window_len</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># Window must be odd</span>
        <span class="n">window_len</span> <span class="o">=</span> <span class="n">window_len</span> <span class="o">+</span> <span class="mi">1</span>

    <span class="c1"># Smooth</span>
    <span class="n">xs_sm</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">savgol_filter</span><span class="p">(</span><span class="n">xs_m</span><span class="p">,</span> <span class="n">window_length</span><span class="o">=</span><span class="n">window_len</span><span class="p">,</span> <span class="n">polyorder</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
                                 <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;interp&#39;</span><span class="p">)</span>
    <span class="n">ys_sm</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">savgol_filter</span><span class="p">(</span><span class="n">ys_m</span><span class="p">,</span> <span class="n">window_length</span><span class="o">=</span><span class="n">window_len</span><span class="p">,</span> <span class="n">polyorder</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
                                 <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;interp&#39;</span><span class="p">)</span>

    <span class="c1"># plt.close(&#39;all&#39;)</span>
    <span class="c1"># plt.plot(xs_sm, ys_sm)</span>
    <span class="c1"># plt.plot(xs_m, ys_m)</span>
    <span class="c1"># plt.axis(&#39;equal&#39;)</span>

    <span class="c1"># Re-sample centerline to even spacing</span>
    <span class="n">s</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">s_ds</span><span class="p">(</span><span class="n">xs_sm</span><span class="p">,</span> <span class="n">ys_sm</span><span class="p">)</span>
    <span class="n">npts</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">/</span><span class="n">grid_spacing</span><span class="p">)</span>
    <span class="n">xy_rs</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">evenly_space_line</span><span class="p">(</span><span class="n">xs_sm</span><span class="p">,</span> <span class="n">ys_sm</span><span class="p">,</span> <span class="n">npts</span><span class="p">)</span>
    <span class="n">xs_rs</span> <span class="o">=</span> <span class="n">xy_rs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">ys_rs</span> <span class="o">=</span> <span class="n">xy_rs</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

    <span class="c1"># Get angles at each point along centerline</span>
    <span class="n">C</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">s</span> <span class="o">=</span> <span class="n">curvars</span><span class="p">(</span><span class="n">xs_rs</span><span class="p">,</span> <span class="n">ys_rs</span><span class="p">,</span> <span class="n">unwrap</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="c1"># Draw perpendiculars at each centerline point</span>
    <span class="n">mesh_hwidth</span> <span class="o">=</span> <span class="n">meshwidth</span><span class="o">/</span><span class="mi">2</span>

    <span class="c1"># Compute slope of perpendicular (w/ref to dx/dy and dy/dx)</span>
    <span class="n">m_inv_xy</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">xs_rs</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">ys_rs</span><span class="p">))</span>
    <span class="n">m_inv_yx</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">ys_rs</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">xs_rs</span><span class="p">))</span>
    <span class="c1"># For storing perpendicular points</span>
    <span class="n">perps</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">ic</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">m_inv_xy</span><span class="p">)):</span>

        <span class="c1"># Compute perpendicular lines based on largest of dx, dy (reduces distortion)</span>
        <span class="k">if</span> <span class="n">m_inv_yx</span><span class="p">[</span><span class="n">ic</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">m_inv_xy</span><span class="p">[</span><span class="n">ic</span><span class="p">]:</span>
            <span class="n">dx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">mesh_hwidth</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">m_inv_yx</span><span class="p">[</span><span class="n">ic</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span>
            <span class="n">dy</span> <span class="o">=</span> <span class="n">dx</span> <span class="o">*</span> <span class="n">m_inv_yx</span><span class="p">[</span><span class="n">ic</span><span class="p">]</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">dy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">mesh_hwidth</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">m_inv_xy</span><span class="p">[</span><span class="n">ic</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span>
            <span class="n">dx</span> <span class="o">=</span> <span class="n">dy</span> <span class="o">*</span> <span class="n">m_inv_xy</span><span class="p">[</span><span class="n">ic</span><span class="p">]</span>

        <span class="n">upper_pt</span> <span class="o">=</span> <span class="p">(</span><span class="n">xs_rs</span><span class="p">[</span><span class="n">ic</span><span class="p">]</span> <span class="o">+</span> <span class="n">dx</span><span class="p">,</span> <span class="n">ys_rs</span><span class="p">[</span><span class="n">ic</span><span class="p">]</span> <span class="o">+</span> <span class="n">dy</span><span class="p">)</span>
        <span class="n">lower_pt</span> <span class="o">=</span> <span class="p">(</span><span class="n">xs_rs</span><span class="p">[</span><span class="n">ic</span><span class="p">]</span> <span class="o">-</span> <span class="n">dx</span><span class="p">,</span> <span class="n">ys_rs</span><span class="p">[</span><span class="n">ic</span><span class="p">]</span> <span class="o">-</span> <span class="n">dy</span><span class="p">)</span>

        <span class="n">perps</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">upper_pt</span><span class="p">,</span> <span class="n">lower_pt</span><span class="p">))</span>

    <span class="c1"># Now orient perpendiculars so that both sides are continuous</span>
    <span class="c1"># NOTE: this method is not guaranteed to work when the grid spacing is much</span>
    <span class="c1"># larger than the buffer width (it likely will be fine, but for highly-</span>
    <span class="c1"># curved bends failure is possible). There are more robust ways to separate</span>
    <span class="c1"># points into left/right bank, but this is quick, dirty, and works for most</span>
    <span class="c1"># applications.</span>
    <span class="n">perp_aligned</span> <span class="o">=</span> <span class="p">[</span><span class="n">perps</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
    <span class="k">for</span> <span class="n">ip</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">perps</span><span class="p">)):</span>

        <span class="n">left_pre</span><span class="p">,</span> <span class="n">right_pre</span> <span class="o">=</span> <span class="n">perp_aligned</span><span class="p">[</span><span class="n">ip</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

        <span class="n">p0</span> <span class="o">=</span> <span class="n">perps</span><span class="p">[</span><span class="n">ip</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">p1</span> <span class="o">=</span> <span class="n">perps</span><span class="p">[</span><span class="n">ip</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">p0</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">left_pre</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">p0</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">left_pre</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">&lt;</span>  <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">p1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">left_pre</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">p1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">left_pre</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span><span class="p">):</span>
            <span class="n">perp_aligned</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">p0</span><span class="p">,</span> <span class="n">p1</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">perp_aligned</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">p1</span><span class="p">,</span> <span class="n">p0</span><span class="p">))</span>

    <span class="c1"># plt.close(&#39;all&#39;)</span>
    <span class="c1"># plt.plot(xs_rs, ys_rs,&#39;.&#39;)</span>
    <span class="c1"># plt.axis(&#39;equal&#39;)</span>
    <span class="c1"># for p in perp_aligned:</span>
    <span class="c1">#     plt.plot(p[0][0], p[0][1], &#39;k.&#39;)</span>
    <span class="c1">#     plt.plot(p[1][0], p[1][1], &#39;r.&#39;)</span>

    <span class="c1"># Trim the centerline to remove the mirrored portions</span>
    <span class="n">start_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">coords</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">xs_rs</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="p">(</span><span class="n">coords</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">ys_rs</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="n">end_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">coords</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">xs_rs</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="p">(</span><span class="n">coords</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">ys_rs</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span> <span class="o">+</span> <span class="mi">1</span>

    <span class="c1"># Build the polygon mesh</span>
    <span class="n">polys</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">start_idx</span><span class="p">,</span> <span class="n">end_idx</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">polys</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">perp_aligned</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">perp_aligned</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span>
                      <span class="n">perp_aligned</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="n">perp_aligned</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span>
                      <span class="n">perp_aligned</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]])</span>

    <span class="n">perps_out</span> <span class="o">=</span> <span class="n">perp_aligned</span><span class="p">[</span><span class="n">start_idx</span><span class="p">:</span><span class="n">end_idx</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">cl_resampled</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="s1">&#39;1,2,0&#39;</span><span class="p">,</span> <span class="n">xs_rs</span><span class="p">,</span> <span class="n">ys_rs</span><span class="p">]</span>
    <span class="n">s_out</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="n">start_idx</span><span class="p">:</span><span class="n">end_idx</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">s</span><span class="p">[</span><span class="n">start_idx</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">perps_out</span><span class="p">,</span> <span class="n">polys</span><span class="p">,</span> <span class="n">cl_resampled</span><span class="p">,</span> <span class="n">s_out</span></div>


<div class="viewcode-block" id="mirror_line_ends"><a class="viewcode-back" href="../../../apiref/rivers.html#rivgraph.rivers.river_utils.mirror_line_ends">[docs]</a><span class="k">def</span> <span class="nf">mirror_line_ends</span><span class="p">(</span><span class="n">xs</span><span class="p">,</span> <span class="n">ys</span><span class="p">,</span> <span class="n">npad</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Reflect both ends of a line.</span>

<span class="sd">    Reflects both ends of a line defined by x and y coordinates. The mirrored</span>
<span class="sd">    distance is set by npad, which refers to the number of vertices along the</span>
<span class="sd">    line to mirror.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Mirror the beginning of the line</span>
    <span class="n">diff_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">xs</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">npad</span><span class="p">])</span>
    <span class="n">xs_m</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">flipud</span><span class="p">(</span><span class="n">xs</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">diff_x</span><span class="p">)),</span> <span class="n">xs</span><span class="p">))</span>
    <span class="n">diff_y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">ys</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">npad</span><span class="p">])</span>
    <span class="n">ys_m</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">flipud</span><span class="p">(</span><span class="n">ys</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">diff_y</span><span class="p">)),</span> <span class="n">ys</span><span class="p">))</span>

    <span class="c1"># Mirror the end of the line</span>
    <span class="n">diff_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">xs</span><span class="p">[</span><span class="o">-</span><span class="n">npad</span><span class="p">:][::</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">xs_m</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">xs_m</span><span class="p">,</span> <span class="n">xs_m</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">diff_x</span><span class="p">)))</span>
    <span class="n">diff_y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">ys</span><span class="p">[</span><span class="o">-</span><span class="n">npad</span><span class="p">:][::</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">ys_m</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">ys_m</span><span class="p">,</span> <span class="n">ys_m</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">diff_y</span><span class="p">)))</span>

    <span class="k">return</span> <span class="n">xs_m</span><span class="p">,</span> <span class="n">ys_m</span></div>


<div class="viewcode-block" id="valleyline_mesh"><a class="viewcode-back" href="../../../apiref/rivers.html#rivgraph.rivers.river_utils.valleyline_mesh">[docs]</a><span class="k">def</span> <span class="nf">valleyline_mesh</span><span class="p">(</span><span class="n">coords</span><span class="p">,</span> <span class="n">avg_chan_width</span><span class="p">,</span> <span class="n">buf_halfwidth</span><span class="p">,</span> <span class="n">grid_spacing</span><span class="p">,</span>
                    <span class="n">smoothing</span><span class="o">=</span><span class="mf">0.15</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generate a mesh over an input river centerline.</span>

<span class="sd">    This function generates a mesh over an input river centerline. The mesh</span>
<span class="sd">    is generated across the valley, not just the channel width, in order to</span>
<span class="sd">    perform larger-scale spatial analyses. With the correct parameter</span>
<span class="sd">    combinations, it can also be used to generate a mesh for smaller-scale</span>
<span class="sd">    analysis, but it is optimized for larger and strange behavior may occur.</span>

<span class="sd">    Many plotting commands are commented out throughout this script as it&#39;s</span>
<span class="sd">    still somewhat in beta mode.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    coords :</span>
<span class="sd">        Nx2 list, tuple, or np.array of x,y coordinates. Coordinates MUST be</span>
<span class="sd">        in projected CRS for viable results.</span>
<span class="sd">    width_chan :</span>
<span class="sd">        estimated width. Units MUST correspond to those of the input</span>
<span class="sd">        coordinates</span>
<span class="sd">    buf_width :</span>
<span class="sd">        distance between centerline and left or right bufferline, in units of</span>
<span class="sd">        coords</span>
<span class="sd">    grid_spacing :</span>
<span class="sd">        fraction of input centerline length that should be used for smoothing</span>
<span class="sd">        to create the valley centerline  (between 0 and 1)</span>
<span class="sd">    smoothing :</span>
<span class="sd">        fraction of centerline length to use for smoothing window</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    lines :</span>
<span class="sd">        the &quot;perpendiculars&quot; to the centerline used to generate the mesh</span>
<span class="sd">    polys :</span>
<span class="sd">        coordinates of the polygons representing the grid cells of the mesh</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">find_cl_intersection_pts_and_distance</span><span class="p">(</span><span class="n">endpts</span><span class="p">,</span> <span class="n">cl</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute intersection points along centerline.</span>

<span class="sd">        Given a list of transect endpoints, this computes the intersection</span>
<span class="sd">        point along the centerline, and then returns the corresponding</span>
<span class="sd">        along-centerline distance to that point from the upstream boundary.</span>

<span class="sd">        End transects might not intersect the centerline. In these cases,</span>
<span class="sd">        we rely on the previous processing steps that artificially extended</span>
<span class="sd">        the centerline and simply drop the transects--effectively clipping</span>
<span class="sd">        the centerline to the first and last transect intersections.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># int_pts = []</span>
        <span class="n">dist_to_int</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">ie</span><span class="p">,</span> <span class="n">eps</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">endpts</span><span class="p">):</span>
            <span class="n">tsect</span> <span class="o">=</span> <span class="n">LineString</span><span class="p">(</span><span class="n">eps</span><span class="p">)</span>
            <span class="n">int_pt</span> <span class="o">=</span> <span class="n">tsect</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">cl</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">int_pt</span><span class="o">.</span><span class="n">coords</span> <span class="o">==</span> <span class="p">[]:</span>  <span class="c1"># There is no intersection</span>
                <span class="c1"># int_pts.append(None)</span>
                <span class="n">dist_to_int</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
                <span class="k">continue</span>

            <span class="c1"># Project the intersection point to the centerline and return</span>
            <span class="c1"># the along-centerline distance of this point</span>
            <span class="n">dist_to_int</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">cl</span><span class="o">.</span><span class="n">project</span><span class="p">(</span><span class="n">int_pt</span><span class="p">)))</span>

            <span class="c1"># int_pts.append(int_pt)</span>

        <span class="n">dist_to_int</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">dist_to_int</span><span class="p">)</span>

        <span class="c1"># Now clip the distances, centerline, and endpoints where there were no intersections</span>
        <span class="n">no_ints</span> <span class="o">=</span> <span class="n">dist_to_int</span> <span class="o">==</span> <span class="kc">None</span>
        <span class="n">dist_to_int</span> <span class="o">=</span> <span class="n">dist_to_int</span><span class="p">[</span><span class="o">~</span><span class="n">no_ints</span><span class="p">]</span>
        <span class="c1"># int_pts = [ip for i, ip in enumerate(int_pts) if no_ints[i] == False]</span>
        <span class="n">cl_clip</span> <span class="o">=</span> <span class="n">LineString</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">cl</span><span class="o">.</span><span class="n">coords</span><span class="o">.</span><span class="n">xy</span><span class="p">[</span><span class="mi">0</span><span class="p">])[</span><span class="o">~</span><span class="n">no_ints</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">cl</span><span class="o">.</span><span class="n">coords</span><span class="o">.</span><span class="n">xy</span><span class="p">[</span><span class="mi">1</span><span class="p">])[</span><span class="o">~</span><span class="n">no_ints</span><span class="p">]))</span>
        <span class="n">ep_clip</span> <span class="o">=</span> <span class="p">[</span><span class="n">ep</span> <span class="k">for</span> <span class="n">iep</span><span class="p">,</span> <span class="n">ep</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">endpts</span><span class="p">)</span> <span class="k">if</span> <span class="n">no_ints</span><span class="p">[</span><span class="n">iep</span><span class="p">]</span> <span class="o">==</span> <span class="kc">False</span><span class="p">]</span>

        <span class="c1"># Reset the origin</span>
        <span class="n">dist_to_int</span> <span class="o">=</span> <span class="n">dist_to_int</span> <span class="o">-</span> <span class="n">dist_to_int</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">dist_to_int</span><span class="p">,</span> <span class="n">cl_clip</span><span class="p">,</span> <span class="n">ep_clip</span>

    <span class="k">def</span> <span class="nf">iterative_cl_pt_mapping</span><span class="p">(</span><span class="n">cl</span><span class="p">,</span> <span class="n">bufdists</span><span class="p">,</span> <span class="n">side</span><span class="p">):</span>

        <span class="n">mapper</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">lines</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

        <span class="n">old</span> <span class="o">=</span> <span class="n">cl</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">bd</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">bufdists</span><span class="p">):</span>

            <span class="n">new</span> <span class="o">=</span> <span class="n">shapely_offset_ls</span><span class="p">(</span><span class="n">cl</span><span class="p">,</span> <span class="n">bd</span><span class="p">,</span> <span class="n">side</span><span class="p">)</span>

            <span class="n">Co</span><span class="p">,</span> <span class="n">Ao</span><span class="p">,</span> <span class="n">so</span> <span class="o">=</span> <span class="n">curvars</span><span class="p">(</span><span class="n">old</span><span class="o">.</span><span class="n">coords</span><span class="o">.</span><span class="n">xy</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">old</span><span class="o">.</span><span class="n">coords</span><span class="o">.</span><span class="n">xy</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">Cn</span><span class="p">,</span> <span class="n">An</span><span class="p">,</span> <span class="n">sn</span> <span class="o">=</span> <span class="n">curvars</span><span class="p">(</span><span class="n">new</span><span class="o">.</span><span class="n">coords</span><span class="o">.</span><span class="n">xy</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">new</span><span class="o">.</span><span class="n">coords</span><span class="o">.</span><span class="n">xy</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

            <span class="n">Ao</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">Ao</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">An</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">An</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

            <span class="n">distance</span><span class="p">,</span> <span class="n">path</span> <span class="o">=</span> <span class="n">fastdtw</span><span class="p">(</span><span class="n">Ao</span><span class="p">,</span> <span class="n">An</span><span class="p">,</span> <span class="n">dist</span><span class="o">=</span><span class="n">euclidean</span><span class="p">)</span>
            <span class="n">path</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>

            <span class="n">mapper</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
            <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new</span><span class="p">)</span>

            <span class="n">old</span> <span class="o">=</span> <span class="n">new</span>

        <span class="k">return</span> <span class="n">lines</span><span class="p">,</span> <span class="n">mapper</span>

    <span class="k">def</span> <span class="nf">get_transect_indices_along_buffered_lines</span><span class="p">(</span><span class="n">cl</span><span class="p">,</span> <span class="n">mapper</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a map of the index of each offset line mapped from the</span>
<span class="sd">        original centerline. Keys are original centerline indices; values</span>
<span class="sd">        are lists the length of number of offsets (i.e. length of bufdists).</span>
<span class="sd">        Really only the last entry in each value is needed, but keeping them</span>
<span class="sd">        all for developing/debugging purposes.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">pts</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">cl</span><span class="o">.</span><span class="n">coords</span><span class="o">.</span><span class="n">xy</span><span class="p">[</span><span class="mi">0</span><span class="p">])):</span>

            <span class="n">idx</span> <span class="o">=</span> <span class="n">i</span>
            <span class="n">idxlist</span> <span class="o">=</span> <span class="p">[</span><span class="n">idx</span><span class="p">]</span>

            <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">mapper</span><span class="p">:</span>
                <span class="n">m</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
                <span class="n">m_idx</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">m</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">idx</span><span class="p">))</span>  <span class="c1"># Get the most-downstrea</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">m_idx</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="n">m_idx</span><span class="p">)</span>
                <span class="n">m_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">m_idx</span><span class="p">)</span>  <span class="c1"># Chooses the most downstream if multiple are available</span>
                <span class="n">idx</span> <span class="o">=</span> <span class="n">m</span><span class="p">[</span><span class="n">m_idx</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
                <span class="n">idxlist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>
            <span class="n">pts</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">idxlist</span>

        <span class="k">return</span> <span class="n">pts</span>

    <span class="k">def</span> <span class="nf">get_transect_endpoints_xy</span><span class="p">(</span><span class="n">lpts</span><span class="p">,</span> <span class="n">rpts</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Given dictionaries that map centerline points to indices along buffered</span>
<span class="sd">        left and right lines, this returns the endpoints of each transect.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">lpts</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">rpts</span><span class="p">)</span>

        <span class="n">endpoints</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">lpts</span><span class="p">)):</span>
            <span class="n">lidx</span> <span class="o">=</span> <span class="n">lpts</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">ridx</span> <span class="o">=</span> <span class="n">rpts</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

            <span class="n">lxy</span> <span class="o">=</span> <span class="p">(</span><span class="n">llines</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">coords</span><span class="o">.</span><span class="n">xy</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">lidx</span><span class="p">],</span> <span class="n">llines</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">coords</span><span class="o">.</span><span class="n">xy</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">lidx</span><span class="p">])</span>
            <span class="n">rxy</span> <span class="o">=</span> <span class="p">(</span><span class="n">rlines</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">coords</span><span class="o">.</span><span class="n">xy</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">ridx</span><span class="p">],</span> <span class="n">rlines</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">coords</span><span class="o">.</span><span class="n">xy</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">ridx</span><span class="p">])</span>
            <span class="n">endpoints</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">lxy</span><span class="p">,</span> <span class="n">rxy</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">endpoints</span>

    <span class="k">def</span> <span class="nf">shapely_offset_ls</span><span class="p">(</span><span class="n">ls</span><span class="p">,</span> <span class="n">dist</span><span class="p">,</span> <span class="n">side</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Just a wrapper around shapely&#39;s offset_linestring() function. That</span>
<span class="sd">        function adds little barbs sometimes to the end of the offset</span>
<span class="sd">        linestring. This function detects and removes those.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">offset</span> <span class="o">=</span> <span class="n">offset_linestring</span><span class="p">(</span><span class="n">ls</span><span class="p">,</span> <span class="n">dist</span><span class="p">,</span> <span class="n">side</span><span class="p">)</span>

        <span class="c1"># Look for barbs by finding abrupt angle changes</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">curvars</span><span class="p">(</span><span class="n">offset</span><span class="o">.</span><span class="n">coords</span><span class="o">.</span><span class="n">xy</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">offset</span><span class="o">.</span><span class="n">coords</span><span class="o">.</span><span class="n">xy</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">possibles</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">A</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mf">1.5</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># Threshold set at 1.5 radians</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">possibles</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">offset</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">st_idx</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">en_idx</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">offset</span><span class="o">.</span><span class="n">coords</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">possibles</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">p</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">offset</span><span class="o">.</span><span class="n">coords</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="n">st_idx</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">st_idx</span><span class="p">,</span> <span class="n">p</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">p</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">offset</span><span class="o">.</span><span class="n">coords</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="n">en_idx</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">en_idx</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>
            <span class="n">offset</span> <span class="o">=</span> <span class="n">LineString</span><span class="p">(</span><span class="n">offset</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="n">st_idx</span><span class="p">:</span><span class="n">en_idx</span><span class="p">])</span>

        <span class="c1"># elif len(possibles) == 1: # Determine if it&#39;s the upstream or downstream that&#39;s barbed</span>
        <span class="c1">#     if possibles[0] &gt; len(A)/2: # Downstream</span>
        <span class="c1">#         offset = LineString(zip(offset.coords.xy[0][:possibles[0]], offset.coords.xy[1][:possibles[0]]))</span>
        <span class="c1">#     else: # Upstream</span>
        <span class="c1">#         offset = LineString(zip(offset.coords.xy[0][possibles[0]:], offset.coords.xy[1][possibles[0]:]))</span>
        <span class="c1"># elif len(possibles) == 2:</span>
        <span class="c1">#     offset = LineString(zip(offset.coords.xy[0][possibles[0]:possibles[1]], offset.coords.xy[1][possibles[0]:possibles[1]]))</span>
        <span class="c1"># else:</span>
        <span class="c1">#     # import pdb; pdb.set_trace()</span>
        <span class="c1">#     raise Warning(&#39;Barbs could not be removed from centerline offset: dist={}, side={}.&#39;.format(dist,side))</span>

        <span class="k">return</span> <span class="n">offset</span>

    <span class="k">def</span> <span class="nf">mirror_lines</span><span class="p">(</span><span class="n">xs_o</span><span class="p">,</span> <span class="n">ys_o</span><span class="p">,</span> <span class="n">npad</span><span class="p">):</span>
        <span class="c1"># Mirror centerline manually since scipy fucks it up - only flip the axis that has the largest displacement</span>
        <span class="c1"># Mirroring done to avoid edge effects when smoothing</span>

        <span class="n">xs_o2</span><span class="p">,</span> <span class="n">ys_o2</span> <span class="o">=</span> <span class="n">mirror_line_ends</span><span class="p">(</span><span class="n">xs_o</span><span class="p">,</span> <span class="n">ys_o</span><span class="p">,</span> <span class="n">npad</span><span class="p">)</span>
        <span class="n">diff_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">xs_o</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">npad</span><span class="p">])</span>
        <span class="n">xs_o2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">flipud</span><span class="p">(</span><span class="n">xs_o</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">diff_x</span><span class="p">)),</span> <span class="n">xs_o</span><span class="p">))</span>
        <span class="n">diff_y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">ys_o</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">npad</span><span class="p">])</span>
        <span class="n">ys_o2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">flipud</span><span class="p">(</span><span class="n">ys_o</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">diff_y</span><span class="p">)),</span> <span class="n">ys_o</span><span class="p">))</span>

        <span class="n">diff_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">xs_o</span><span class="p">[</span><span class="o">-</span><span class="n">npad</span><span class="p">:][::</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">xs_o2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">xs_o2</span><span class="p">,</span> <span class="n">xs_o2</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">diff_x</span><span class="p">)))</span>
        <span class="n">diff_y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">ys_o</span><span class="p">[</span><span class="o">-</span><span class="n">npad</span><span class="p">:][::</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">ys_o2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">ys_o2</span><span class="p">,</span> <span class="n">ys_o2</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">diff_y</span><span class="p">)))</span>

        <span class="k">return</span><span class="p">(</span><span class="n">xs_o2</span><span class="p">,</span> <span class="n">ys_o2</span><span class="p">)</span>

    <span class="sd">&quot;&quot;&quot; Function code begins here &quot;&quot;&quot;</span>
    <span class="c1"># obj = ind</span>
    <span class="c1"># coords = obj.centerline</span>
    <span class="c1"># avg_chan_width = obj.avg_chan_width</span>
    <span class="c1"># buf_halfwidth = obj.max_valley_width_pixels * obj.pixlen * 1.1</span>
    <span class="c1"># grid_spacing = avg_chan_width</span>
    <span class="c1"># smoothing = 0.1</span>

    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">coords</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">coords</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">4</span><span class="p">:</span>
        <span class="n">coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">coords</span><span class="p">)</span>

    <span class="c1"># Separate coordinates into xs and ys (o indicates original coordinates)</span>
    <span class="n">xs_o</span> <span class="o">=</span> <span class="n">coords</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>
    <span class="n">ys_o</span> <span class="o">=</span> <span class="n">coords</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span>

    <span class="c1"># Set smoothing window size based on smoothing parameter and centerline length</span>
    <span class="n">s</span><span class="p">,</span> <span class="n">ds</span> <span class="o">=</span> <span class="n">s_ds</span><span class="p">(</span><span class="n">xs_o</span><span class="p">,</span> <span class="n">ys_o</span><span class="p">)</span>
    <span class="n">window_len</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">smoothing</span> <span class="o">*</span> <span class="n">s</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">ds</span><span class="p">))</span>
    <span class="n">window_len</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">xs_o</span><span class="p">)</span><span class="o">/</span><span class="mi">5</span><span class="p">,</span> <span class="n">window_len</span><span class="p">))</span>  <span class="c1"># Smoothing window cannot be longer than 1/5 the centerline</span>
    <span class="k">if</span> <span class="n">window_len</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># Window must be odd</span>
        <span class="n">window_len</span> <span class="o">=</span> <span class="n">window_len</span> <span class="o">+</span> <span class="mi">1</span>

    <span class="c1"># Extend the centerline ends to avoid boundary effects; we&#39;ll clip them later</span>
    <span class="n">xs_o2</span><span class="p">,</span> <span class="n">ys_o2</span> <span class="o">=</span> <span class="n">mirror_lines</span><span class="p">(</span><span class="n">xs_o</span><span class="p">,</span> <span class="n">ys_o</span><span class="p">,</span> <span class="n">window_len</span><span class="p">)</span>

    <span class="c1"># Smooth the coordinates before buffering</span>
    <span class="n">xs_sm</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">savgol_filter</span><span class="p">(</span><span class="n">xs_o2</span><span class="p">,</span> <span class="n">window_length</span><span class="o">=</span><span class="n">window_len</span><span class="p">,</span> <span class="n">polyorder</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
                                 <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;interp&#39;</span><span class="p">)</span>
    <span class="n">ys_sm</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">savgol_filter</span><span class="p">(</span><span class="n">ys_o2</span><span class="p">,</span> <span class="n">window_length</span><span class="o">=</span><span class="n">window_len</span><span class="p">,</span> <span class="n">polyorder</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
                                 <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;interp&#39;</span><span class="p">)</span>

    <span class="c1"># Create shapely LineString centerline</span>
    <span class="n">cl</span> <span class="o">=</span> <span class="n">LineString</span><span class="p">([(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">xs_sm</span><span class="p">,</span> <span class="n">ys_sm</span><span class="p">)])</span>

    <span class="c1"># Simplify the linestring</span>
    <span class="n">npts</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">cl</span><span class="o">.</span><span class="n">length</span><span class="o">/</span><span class="n">avg_chan_width</span><span class="o">/</span><span class="mi">20</span><span class="p">),</span> <span class="mi">25</span><span class="p">)</span>
    <span class="n">tol</span> <span class="o">=</span> <span class="n">avg_chan_width</span><span class="o">/</span><span class="mi">100</span>
    <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
        <span class="n">cl2</span> <span class="o">=</span> <span class="n">cl</span><span class="o">.</span><span class="n">simplify</span><span class="p">(</span><span class="n">tol</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">cl2</span><span class="o">.</span><span class="n">coords</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">npts</span><span class="p">:</span>
            <span class="n">tol</span> <span class="o">=</span> <span class="n">tol</span> <span class="o">*</span> <span class="mf">1.1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">break</span>

    <span class="c1"># Offset valley centerline for left and right valleylines</span>
    <span class="n">bdists</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">buf_halfwidth</span><span class="p">,</span>
                         <span class="nb">min</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">buf_halfwidth</span><span class="o">/</span><span class="n">avg_chan_width</span><span class="p">),</span> <span class="mi">25</span><span class="p">))</span>
    <span class="n">bdists</span> <span class="o">=</span> <span class="n">bdists</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>

    <span class="c1"># Iteratively create offset lines and map each centerline index</span>
    <span class="n">llines</span><span class="p">,</span> <span class="n">lmap</span> <span class="o">=</span> <span class="n">iterative_cl_pt_mapping</span><span class="p">(</span><span class="n">cl2</span><span class="p">,</span> <span class="n">bdists</span><span class="p">,</span> <span class="s1">&#39;left&#39;</span><span class="p">)</span>
    <span class="n">rlines</span><span class="p">,</span> <span class="n">rmap</span> <span class="o">=</span> <span class="n">iterative_cl_pt_mapping</span><span class="p">(</span><span class="n">cl2</span><span class="p">,</span> <span class="n">bdists</span><span class="p">,</span> <span class="s1">&#39;right&#39;</span><span class="p">)</span>

    <span class="n">lpts</span> <span class="o">=</span> <span class="n">get_transect_indices_along_buffered_lines</span><span class="p">(</span><span class="n">cl2</span><span class="p">,</span> <span class="n">lmap</span><span class="p">)</span>
    <span class="n">rpts</span> <span class="o">=</span> <span class="n">get_transect_indices_along_buffered_lines</span><span class="p">(</span><span class="n">cl2</span><span class="p">,</span> <span class="n">rmap</span><span class="p">)</span>

    <span class="n">endpts</span> <span class="o">=</span> <span class="n">get_transect_endpoints_xy</span><span class="p">(</span><span class="n">lpts</span><span class="p">,</span> <span class="n">rpts</span><span class="p">)</span>

    <span class="n">dists</span><span class="p">,</span> <span class="n">cl_clip</span><span class="p">,</span> <span class="n">ep_clip</span> <span class="o">=</span> <span class="n">find_cl_intersection_pts_and_distance</span><span class="p">(</span><span class="n">endpts</span><span class="p">,</span> <span class="n">cl2</span><span class="p">)</span>
    <span class="n">dists</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="nb">float</span><span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">dists</span><span class="p">])</span>  <span class="c1"># avoid dtype(&#39;O&#39;) error in numpy.interp</span>

    <span class="c1"># Now build the interpolating functions</span>
    <span class="n">dists_to_interpolate</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">dists</span><span class="p">),</span> <span class="n">grid_spacing</span><span class="p">)</span>
    <span class="n">xp_l</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">ep</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">ep</span> <span class="ow">in</span> <span class="n">ep_clip</span><span class="p">])</span>
    <span class="n">yp_l</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">ep</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">ep</span> <span class="ow">in</span> <span class="n">ep_clip</span><span class="p">])</span>
    <span class="n">xp_r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">ep</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">ep</span> <span class="ow">in</span> <span class="n">ep_clip</span><span class="p">])</span>
    <span class="n">yp_r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">ep</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">ep</span> <span class="ow">in</span> <span class="n">ep_clip</span><span class="p">])</span>

    <span class="c1"># Interpolate</span>
    <span class="n">x_left</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">interp</span><span class="p">(</span><span class="n">dists_to_interpolate</span><span class="p">,</span> <span class="n">dists</span><span class="p">,</span> <span class="n">xp_l</span><span class="p">)</span>
    <span class="n">y_left</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">interp</span><span class="p">(</span><span class="n">dists_to_interpolate</span><span class="p">,</span> <span class="n">dists</span><span class="p">,</span> <span class="n">yp_l</span><span class="p">)</span>
    <span class="n">x_right</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">interp</span><span class="p">(</span><span class="n">dists_to_interpolate</span><span class="p">,</span> <span class="n">dists</span><span class="p">,</span> <span class="n">xp_r</span><span class="p">)</span>
    <span class="n">y_right</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">interp</span><span class="p">(</span><span class="n">dists_to_interpolate</span><span class="p">,</span> <span class="n">dists</span><span class="p">,</span> <span class="n">yp_r</span><span class="p">)</span>

    <span class="c1"># # Plot the grid</span>
    <span class="c1"># plt.close(&#39;all&#39;)</span>
    <span class="c1"># plt.plot(cl.coords.xy[0], cl.coords.xy[1], &#39;--k&#39;)</span>
    <span class="c1"># plt.axis(&#39;equal&#39;)</span>
    <span class="c1"># for xl, yl, xr, yr in zip(x_left, y_left, x_right, y_right):</span>
    <span class="c1">#     plt.plot((xr, xl), (yr,yl))</span>

    <span class="c1"># Mesh is generated; export transects and polygons as shapely geometries</span>
    <span class="n">transects</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">xl</span><span class="p">,</span> <span class="n">yl</span><span class="p">,</span> <span class="n">xr</span><span class="p">,</span> <span class="n">yr</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">x_left</span><span class="p">,</span> <span class="n">y_left</span><span class="p">,</span> <span class="n">x_right</span><span class="p">,</span> <span class="n">y_right</span><span class="p">):</span>
        <span class="n">transects</span><span class="o">.</span><span class="n">append</span><span class="p">(((</span><span class="n">xl</span><span class="p">,</span> <span class="n">yl</span><span class="p">),</span> <span class="p">(</span><span class="n">xr</span><span class="p">,</span> <span class="n">yr</span><span class="p">)))</span>

    <span class="c1"># The centerline was elongated to avoid boundary effects, so now we can</span>
    <span class="c1"># clip the transects to only those that are needed</span>
    <span class="n">cl_orig</span> <span class="o">=</span> <span class="n">LineString</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">xs_o</span><span class="p">,</span> <span class="n">ys_o</span><span class="p">))</span>
    <span class="n">intersects_cl</span> <span class="o">=</span> <span class="p">[</span><span class="n">LineString</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="o">.</span><span class="n">intersects</span><span class="p">(</span><span class="n">cl_orig</span><span class="p">)</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">transects</span><span class="p">]</span>
    <span class="n">first_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">intersects_cl</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="n">last_idx</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">intersects_cl</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">intersects_cl</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">1</span>  <span class="c1"># -1/+1 for explicitness</span>
    <span class="n">transects</span> <span class="o">=</span> <span class="p">[</span><span class="n">transects</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">first_idx</span><span class="p">,</span> <span class="n">last_idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span>

    <span class="c1"># Create mesh polygons</span>
    <span class="n">polys</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">transects</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">polys</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Polygon</span><span class="p">([</span><span class="n">transects</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">transects</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span>
                     <span class="n">transects</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="n">transects</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span>
                     <span class="n">transects</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]]))</span>

    <span class="c1"># Convert transects to shapely objects</span>
    <span class="n">transects</span> <span class="o">=</span> <span class="p">[</span><span class="n">LineString</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">transects</span><span class="p">]</span>

    <span class="c1"># Clip the smooth centerline for return</span>
    <span class="n">xs_sm</span> <span class="o">=</span> <span class="n">xs_sm</span><span class="p">[</span><span class="n">window_len</span><span class="o">-</span><span class="mi">1</span><span class="p">:(</span><span class="nb">len</span><span class="p">(</span><span class="n">xs_sm</span><span class="p">)</span><span class="o">-</span><span class="n">window_len</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span>
    <span class="n">ys_sm</span> <span class="o">=</span> <span class="n">ys_sm</span><span class="p">[</span><span class="n">window_len</span><span class="o">-</span><span class="mi">1</span><span class="p">:(</span><span class="nb">len</span><span class="p">(</span><span class="n">ys_sm</span><span class="p">)</span><span class="o">-</span><span class="n">window_len</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span>
    <span class="n">cl_smooth</span> <span class="o">=</span> <span class="n">LineString</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">xs_sm</span><span class="p">,</span> <span class="n">ys_sm</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">transects</span><span class="p">,</span> <span class="n">polys</span><span class="p">,</span> <span class="n">cl_smooth</span></div>


<div class="viewcode-block" id="max_valley_width"><a class="viewcode-back" href="../../../apiref/rivers.html#rivgraph.rivers.river_utils.max_valley_width">[docs]</a><span class="k">def</span> <span class="nf">max_valley_width</span><span class="p">(</span><span class="n">Imask</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes the maximum valley width of the input mask. Finds the single</span>
<span class="sd">    largest blob in the mask, fills its holes, then uses the distance transform</span>
<span class="sd">    to find the largest width.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    Imask : np.array</span>
<span class="sd">        Binary mask from which the centerline was computed.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    max_valley_width : float</span>
<span class="sd">        Maximum width of the channel belt, useful for computing a mesh. Units</span>
<span class="sd">        are pixels, so be careful to re-convert.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">Imask</span> <span class="o">=</span> <span class="n">iu</span><span class="o">.</span><span class="n">largest_blobs</span><span class="p">(</span><span class="n">Imask</span><span class="p">,</span> <span class="n">nlargest</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">action</span><span class="o">=</span><span class="s1">&#39;keep&#39;</span><span class="p">)</span>
    <span class="n">Imask</span> <span class="o">=</span> <span class="n">iu</span><span class="o">.</span><span class="n">fill_holes</span><span class="p">(</span><span class="n">Imask</span><span class="p">)</span>
    <span class="n">Idist</span> <span class="o">=</span> <span class="n">distance_transform_edt</span><span class="p">(</span><span class="n">Imask</span><span class="p">)</span>
    <span class="n">max_valley_width</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">Idist</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span>

    <span class="k">return</span> <span class="n">max_valley_width</span></div>


<div class="viewcode-block" id="curvars"><a class="viewcode-back" href="../../../apiref/rivers.html#rivgraph.rivers.river_utils.curvars">[docs]</a><span class="k">def</span> <span class="nf">curvars</span><span class="p">(</span><span class="n">xs</span><span class="p">,</span> <span class="n">ys</span><span class="p">,</span> <span class="n">unwrap</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute curvature (and intermediate variables) for a given set of x,y</span>
<span class="sd">    coordinates.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">xs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">xs</span><span class="p">)</span>
    <span class="n">ys</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">ys</span><span class="p">)</span>

    <span class="n">xAi0</span> <span class="o">=</span> <span class="n">xs</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">xAi1</span> <span class="o">=</span> <span class="n">xs</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
    <span class="n">yAi0</span> <span class="o">=</span> <span class="n">ys</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">yAi1</span> <span class="o">=</span> <span class="n">ys</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>

    <span class="c1"># Compute angles between x,y nodes</span>
<span class="c1">#    A = np.arctan(np.divide(yAi1-yAi0,xAi1-xAi0))</span>
    <span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">yAi1</span><span class="o">-</span><span class="n">yAi0</span><span class="p">,</span> <span class="n">xAi1</span><span class="o">-</span><span class="n">xAi0</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">unwrap</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">True</span><span class="p">:</span>
        <span class="n">Acopy</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="c1"># Fix phase jumps in angle larger than pi</span>
    <span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unwrap</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>

    <span class="c1"># Compute distance and cumulative distance between nodes</span>
    <span class="n">s</span><span class="p">,</span> <span class="n">ds</span> <span class="o">=</span> <span class="n">s_ds</span><span class="p">(</span><span class="n">xs</span><span class="p">,</span> <span class="n">ys</span><span class="p">)</span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

    <span class="c1"># Compute curvature via central differencing</span>
    <span class="c1"># See: http://terpconnect.umd.edu/~toh/spectrum/Differentiation.html</span>
    <span class="n">sd</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)])</span>
    <span class="n">sd</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
    <span class="n">sd</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

    <span class="n">su</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)])</span>
    <span class="n">su</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
    <span class="n">su</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="o">-</span><span class="mi">3</span><span class="p">]</span>

    <span class="n">Ad</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)])</span>
    <span class="n">Ad</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
    <span class="n">Ad</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

    <span class="n">Au</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)])</span>
    <span class="n">Au</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
    <span class="n">Au</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="o">-</span><span class="mi">3</span><span class="p">]</span>

    <span class="c1"># Curvatures - checked against Matlab implementation, OK</span>
    <span class="n">C</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">divide</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">divide</span><span class="p">(</span><span class="n">Au</span><span class="o">-</span><span class="n">A</span><span class="p">,</span> <span class="n">su</span><span class="o">-</span><span class="n">s</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">s</span><span class="o">-</span><span class="n">sd</span><span class="p">)</span><span class="o">+</span><span class="n">np</span><span class="o">.</span><span class="n">divide</span><span class="p">(</span><span class="n">A</span><span class="o">-</span><span class="n">Ad</span><span class="p">,</span> <span class="n">s</span><span class="o">-</span><span class="n">sd</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">su</span><span class="o">-</span><span class="n">s</span><span class="p">)),</span> <span class="p">(</span><span class="n">su</span><span class="o">-</span><span class="n">sd</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">unwrap</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">True</span><span class="p">:</span>
        <span class="n">Areturn</span> <span class="o">=</span> <span class="n">Acopy</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">Areturn</span> <span class="o">=</span> <span class="n">A</span>

    <span class="k">return</span> <span class="n">C</span><span class="p">,</span> <span class="n">Areturn</span><span class="p">,</span> <span class="n">s</span></div>


<span class="k">def</span> <span class="nf">s_ds</span><span class="p">(</span><span class="n">xs</span><span class="p">,</span> <span class="n">ys</span><span class="p">):</span>

    <span class="n">ds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">xs</span><span class="p">))</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">ys</span><span class="p">))</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">ds</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">s</span><span class="p">,</span> <span class="n">ds</span>


<div class="viewcode-block" id="smooth_curvatures"><a class="viewcode-back" href="../../../apiref/rivers.html#rivgraph.rivers.river_utils.smooth_curvatures">[docs]</a><span class="k">def</span> <span class="nf">smooth_curvatures</span><span class="p">(</span><span class="n">C</span><span class="p">,</span> <span class="n">cvtarget</span><span class="p">,</span> <span class="n">tolerance</span><span class="o">=</span><span class="mi">10</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Smoothes a curvature signal until the coefficient of variation of its</span>
<span class="sd">    differenced curvatures is within tolerance percent.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">scipy.stats</span> <span class="kn">import</span> <span class="n">variation</span>

    <span class="n">smoothstep</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">C</span><span class="p">)</span><span class="o">/</span><span class="mi">100</span><span class="p">)</span>
    <span class="n">window</span> <span class="o">=</span> <span class="n">smoothstep</span>
    <span class="k">if</span> <span class="n">window</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># Window must be odd</span>
        <span class="n">window</span> <span class="o">=</span> <span class="n">window</span> <span class="o">+</span> <span class="mi">1</span>

    <span class="n">cv</span> <span class="o">=</span> <span class="mi">10000</span>
    <span class="k">while</span> <span class="nb">abs</span><span class="p">((</span><span class="n">cv</span><span class="o">-</span><span class="n">cvtarget</span><span class="p">)</span><span class="o">/</span><span class="n">cv</span><span class="o">*</span><span class="mi">100</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">tolerance</span><span class="p">:</span>
        <span class="n">Cs</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">savgol_filter</span><span class="p">(</span><span class="n">C</span><span class="p">,</span> <span class="n">window_length</span><span class="o">=</span><span class="n">window</span><span class="p">,</span> <span class="n">polyorder</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
                                  <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;interp&#39;</span><span class="p">)</span>
        <span class="n">cv</span> <span class="o">=</span> <span class="n">variation</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">Cs</span><span class="p">))</span>

        <span class="n">window</span> <span class="o">=</span> <span class="n">window</span> <span class="o">+</span> <span class="n">smoothstep</span>
        <span class="k">if</span> <span class="n">window</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># Window must be odd</span>
            <span class="n">window</span> <span class="o">=</span> <span class="n">window</span> <span class="o">+</span> <span class="mi">1</span>

        <span class="k">if</span> <span class="n">window</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">C</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Could not find solution.&#39;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">Cs</span>

    <span class="k">return</span> <span class="n">Cs</span></div>


<div class="viewcode-block" id="inflection_points"><a class="viewcode-back" href="../../../apiref/rivers.html#rivgraph.rivers.river_utils.inflection_points">[docs]</a><span class="k">def</span> <span class="nf">inflection_points</span><span class="p">(</span><span class="n">C</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns the inflection points for an input curvature signal.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">infs1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">C</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="n">C</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="n">infs2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">C</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">,</span> <span class="n">C</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="n">infs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">infs1</span><span class="p">,</span> <span class="n">infs2</span><span class="p">)))</span>

    <span class="k">return</span> <span class="n">infs</span></div>


<span class="k">class</span> <span class="nc">centerline</span><span class="p">():</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">attribs</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        attribs is a dictionary with attributes; can be single values like</span>
<span class="sd">        average channel width or one value per coordinate like local width.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Store original coordinates</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">xo</span> <span class="o">=</span> <span class="n">x</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">yo</span> <span class="o">=</span> <span class="n">y</span>

        <span class="c1"># Store attributes</span>
        <span class="k">if</span> <span class="n">attribs</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">attribs</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>

                <span class="k">try</span><span class="p">:</span>
                    <span class="n">alen</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">attribs</span><span class="p">[</span><span class="n">a</span><span class="p">])</span>
                <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                    <span class="n">alen</span> <span class="o">=</span> <span class="mi">1</span>

                <span class="k">if</span> <span class="n">alen</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">alen</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
                    <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">attribs</span><span class="p">[</span><span class="n">a</span><span class="p">])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Attribute () does not have the proper length and is not being stored.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">a</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">__get_x_and_y</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>

        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;xrs&#39;</span><span class="p">):</span>
            <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">xrs</span>
            <span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">yrs</span>
            <span class="n">vers</span> <span class="o">=</span> <span class="s1">&#39;resampled&#39;</span>
        <span class="k">elif</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;xs&#39;</span><span class="p">):</span>
            <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">xs</span>
            <span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ys</span>
            <span class="n">vers</span> <span class="o">=</span> <span class="s1">&#39;smooth&#39;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">xo</span>
            <span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">yo</span>
            <span class="n">vers</span> <span class="o">=</span> <span class="s1">&#39;original&#39;</span>

        <span class="k">return</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">vers</span>


    <span class="k">def</span> <span class="nf">smooth</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Smooths the x and y coordinates of the centerline using a k-th order</span>
<span class="sd">        Savitzky-Golay filter.</span>

<span class="sd">        window refers to the number of points to use in the moving window;</span>
<span class="sd">        must be odd n is the number of times to perform the smoothing.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">x</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__get_x_and_y</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">window</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;window_cl&#39;</span><span class="p">):</span>
                <span class="n">window</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">window_cl</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Must provide a smoothing window.&#39;</span><span class="p">)</span>
                <span class="k">return</span>

        <span class="c1"># Ensure window is integer and odd</span>
        <span class="n">window</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">window</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">window</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">window</span> <span class="o">=</span> <span class="n">window</span> <span class="o">+</span> <span class="mi">1</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">xs</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">savgol_filter</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">window_length</span><span class="o">=</span><span class="n">window</span><span class="p">,</span> <span class="n">polyorder</span><span class="o">=</span><span class="n">k</span><span class="p">,</span>
                                       <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;interp&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ys</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">savgol_filter</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">window_length</span><span class="o">=</span><span class="n">window</span><span class="p">,</span> <span class="n">polyorder</span><span class="o">=</span><span class="n">k</span><span class="p">,</span>
                                       <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;interp&#39;</span><span class="p">)</span>

        <span class="c1"># Could make this recursive but if a non-default x,y are passed in, it would not function as expected</span>
        <span class="k">if</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">xs</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">savgol_filter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xs</span><span class="p">,</span> <span class="n">window_length</span><span class="o">=</span><span class="n">window</span><span class="p">,</span>
                                               <span class="n">polyorder</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;interp&#39;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">ys</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">savgol_filter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ys</span><span class="p">,</span> <span class="n">window_length</span><span class="o">=</span><span class="n">window</span><span class="p">,</span>
                                               <span class="n">polyorder</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;interp&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">resample</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        If no arguments are provided for x and y, will resample the smoothed</span>
<span class="sd">        coordinates if available, else will resample the original coordinates.</span>

<span class="sd">        N is the number of points that the resulting centerline</span>
<span class="sd">        should contain.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">x</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__get_x_and_y</span><span class="p">()</span>

        <span class="n">xy</span><span class="p">,</span> <span class="n">spline</span> <span class="o">=</span> <span class="n">evenly_space_line</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">npts</span><span class="o">=</span><span class="n">N</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">xrs</span> <span class="o">=</span> <span class="n">xy</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">yrs</span> <span class="o">=</span> <span class="n">xy</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">s</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>

        <span class="k">if</span> <span class="n">x</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__get_x_and_y</span><span class="p">()</span>

        <span class="n">sss</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">s_ds</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">sss</span>

    <span class="k">def</span> <span class="nf">ds</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>

        <span class="k">if</span> <span class="n">x</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__get_x_and_y</span><span class="p">()</span>

        <span class="n">_</span><span class="p">,</span> <span class="n">dss</span> <span class="o">=</span> <span class="n">s_ds</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">dss</span>

    <span class="k">def</span> <span class="nf">C</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Important: curvatures are negativized to match the zs approach</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">x</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__get_x_and_y</span><span class="p">()</span>

        <span class="n">Cs</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">curvars</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">unwrap</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">Cs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">Cs</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">return</span> <span class="o">-</span><span class="n">Cs</span>

    <span class="k">def</span> <span class="nf">Csmooth</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>

        <span class="k">if</span> <span class="n">window</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;window_C&#39;</span><span class="p">):</span>
                <span class="n">window</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">window_C</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Must provide a smoothing window.&#39;</span><span class="p">)</span>
                <span class="k">return</span>

        <span class="n">Cs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">C</span><span class="p">()</span>
        <span class="n">Cs</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">savgol_filter</span><span class="p">(</span><span class="n">Cs</span><span class="p">,</span> <span class="n">window_length</span><span class="o">=</span><span class="n">window</span><span class="p">,</span> <span class="n">polyorder</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
                                  <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;interp&#39;</span><span class="p">)</span>
<span class="c1">#            Cs = signal.medfilt(Cs,kernel_size=5)</span>
        <span class="k">return</span> <span class="n">Cs</span>

    <span class="k">def</span> <span class="nf">infs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Finds inflection points.</span>

<span class="sd">        N is the number of expected inflection points. It can be estimated</span>
<span class="sd">        from N ~= centerline length / 10W, but visual inspection is usually</span>
<span class="sd">        best.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">x</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__get_x_and_y</span><span class="p">()</span>

        <span class="c1"># Use centerline oversmoothing to find inflection points</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">infs_os</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">inflection_pts_oversmooth</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">n_infs</span><span class="o">=</span><span class="n">N</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">infsC</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;C&#39;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">curvature</span><span class="p">()</span>

        <span class="c1"># Use curvature to find inflection points</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">infs_C</span> <span class="o">=</span> <span class="n">inflection_points</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">C</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">intersection_points</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">y2</span><span class="p">,</span> <span class="n">x1</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">y1</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>

        <span class="k">if</span> <span class="n">x1</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">x1</span><span class="p">,</span> <span class="n">y1</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__get_x_and_y</span><span class="p">()</span>

        <span class="n">ls1</span> <span class="o">=</span> <span class="n">LineString</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">y1</span><span class="p">))</span>
        <span class="n">ls2</span> <span class="o">=</span> <span class="n">LineString</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">x2</span><span class="p">,</span> <span class="n">y2</span><span class="p">))</span>
        <span class="n">ls_intersections</span> <span class="o">=</span> <span class="n">ls1</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">ls2</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ints_all</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">x1</span><span class="o">-</span><span class="n">pt</span><span class="o">.</span><span class="n">coords</span><span class="o">.</span><span class="n">xy</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">y1</span><span class="o">-</span><span class="n">pt</span><span class="o">.</span><span class="n">coords</span><span class="o">.</span><span class="n">xy</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span> <span class="k">for</span> <span class="n">pt</span> <span class="ow">in</span> <span class="n">ls_intersections</span><span class="p">]))</span> <span class="c1"># locations of zero migration</span>

        <span class="c1"># Map the intersection points so that there is one point for every</span>
        <span class="c1"># pair of inflection points in inf_os</span>
        <span class="c1"># If there is only one intersection point, use it.</span>
        <span class="c1"># If none, use the first inflection point?</span>
        <span class="c1"># If multiple, use the one closest to the first inflection point</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;infs_os&#39;</span><span class="p">):</span>

            <span class="n">s</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">s</span><span class="p">()</span>

            <span class="c1"># Compute the average bend length from the inflection points</span>
            <span class="n">ints</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">s</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">s</span><span class="p">()</span>
            <span class="n">abl</span> <span class="o">=</span> <span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">infs_os</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span> <span class="o">-</span> <span class="n">s</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">infs_os</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span><span class="o">/</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">infs_os</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">infs_os</span><span class="p">)):</span>

                <span class="n">i0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">infs_os</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

                <span class="c1"># Find nearest intersection point for first inflection</span>
                <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">intidx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">i0</span><span class="p">]</span> <span class="o">-</span> <span class="n">s</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ints_all</span><span class="p">]))</span>
                    <span class="n">ints</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ints_all</span><span class="p">[</span><span class="n">intidx</span><span class="p">])</span>

                <span class="c1"># Else find the nearest interesection point that is downstream of the bend&#39;s first inflection point</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">possible_ints</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ints_all</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ints_all</span> <span class="o">&gt;</span> <span class="n">ints</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span>
                    <span class="n">dists</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">possible_ints</span><span class="p">]</span> <span class="o">-</span> <span class="n">s</span><span class="p">[</span><span class="n">i0</span><span class="p">])</span>
                    <span class="n">ints</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">possible_ints</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">dists</span><span class="p">)])</span>

                <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">infs_os</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                    <span class="k">break</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">ints</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">ints</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Could not map intersections to inflection point pairs because infs_os not computed. Run infs() first.&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">mig_rate_zs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">y2</span><span class="p">,</span> <span class="n">dt_years</span><span class="p">,</span> <span class="n">x1</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">y1</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute migration rate using Sylvester et al&#39;s method of</span>
<span class="sd">        dynamic time warping.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">x1</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">x1</span><span class="p">,</span> <span class="n">y1</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__get_x_and_y</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">window</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;window_C&#39;</span><span class="p">):</span>
                <span class="n">window</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">window_C</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">window</span> <span class="o">=</span> <span class="mi">5</span>  <span class="c1"># must be greater than the polyorder, which is 3 by default</span>

        <span class="kn">import</span> <span class="nn">os</span>
        <span class="kn">import</span> <span class="nn">sys</span>
        <span class="n">script_dir</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;C:\Users\Jon\Desktop\Research\Koyukukon\Normalize migration rates\Code\curvaturepy-master&quot;</span>
        <span class="n">sys</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">abspath</span><span class="p">(</span><span class="n">script_dir</span><span class="p">))</span>
        <span class="kn">import</span> <span class="nn">cline_analysis</span> <span class="k">as</span> <span class="nn">ca</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">mr_zs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">mrs_zs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">p_zs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">q_zs</span> <span class="o">=</span> <span class="n">ca</span><span class="o">.</span><span class="n">get_migr_rate</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">y1</span><span class="p">,</span> <span class="n">y2</span><span class="p">,</span> <span class="n">dt_years</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

        <span class="c1"># Smooth</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mr_zs_sm</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">savgol_filter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mr_zs</span><span class="p">,</span> <span class="n">window_length</span><span class="o">=</span><span class="n">window</span><span class="p">,</span>
                                             <span class="n">polyorder</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;interp&#39;</span><span class="p">)</span>

        <span class="c1"># Set cutoff-affected and erodibility-affected bends to NaN</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mr_zs_nan</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mr_zs</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mr_zs_sm_nan</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mr_zs_sm</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;cut_ids&#39;</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cut_ids</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">mr_zs_nan</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">infs_os</span><span class="p">[</span><span class="n">c</span><span class="p">]:</span><span class="bp">self</span><span class="o">.</span><span class="n">infs_os</span><span class="p">[</span><span class="n">c</span><span class="o">+</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">NaN</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">mr_zs_sm_nan</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">infs_os</span><span class="p">[</span><span class="n">c</span><span class="p">]:</span><span class="bp">self</span><span class="o">.</span><span class="n">infs_os</span><span class="p">[</span><span class="n">c</span><span class="o">+</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">NaN</span>

        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;erode_ids&#39;</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">erode_ids</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">mr_zs_nan</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">infs_os</span><span class="p">[</span><span class="n">e</span><span class="p">]:</span><span class="bp">self</span><span class="o">.</span><span class="n">infs_os</span><span class="p">[</span><span class="n">e</span><span class="o">+</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">NaN</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">mr_zs_sm_nan</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">infs_os</span><span class="p">[</span><span class="n">e</span><span class="p">]:</span><span class="bp">self</span><span class="o">.</span><span class="n">infs_os</span><span class="p">[</span><span class="n">e</span><span class="o">+</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">NaN</span>

    <span class="k">def</span> <span class="nf">plot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>

        <span class="k">if</span> <span class="n">x</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">version</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__get_x_and_y</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">version</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>

        <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">()</span>
        <span class="n">legend</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="s1">&#39;k&#39;</span><span class="p">)</span>
        <span class="n">legend</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">version</span> <span class="o">+</span> <span class="s1">&#39; centerline&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;infs_os&#39;</span><span class="p">):</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">infs_os</span><span class="p">],</span> <span class="n">y</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">infs_os</span><span class="p">],</span> <span class="s1">&#39;rs&#39;</span><span class="p">)</span>
            <span class="n">legend</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;inflection points&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;ints_all&#39;</span><span class="p">):</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ints_all</span><span class="p">],</span>  <span class="n">y</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ints_all</span><span class="p">],</span> <span class="s1">&#39;go&#39;</span><span class="p">)</span>
            <span class="n">legend</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;intersection points&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;ints&#39;</span><span class="p">):</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ints</span><span class="p">],</span> <span class="n">y</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ints</span><span class="p">],</span> <span class="s1">&#39;b^&#39;</span><span class="p">)</span>
            <span class="n">legend</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;intersection points (mapped)&#39;</span><span class="p">)</span>

        <span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">legend</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;equal&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">zs_plot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Copied verbatim from https://github.com/zsylvester/curvaturepy/blob/master/Purus_2_migration_rates.ipynb</span>
<span class="sd">        Slight modifications for meshing in the centerline class.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;infs_os&#39;</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Must compute inflection points first.&#39;</span><span class="p">)</span>
            <span class="k">return</span>

        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;ints&#39;</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Must compute intersections first.&#39;</span><span class="p">)</span>
            <span class="k">return</span>

        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;mr_zs_nan&#39;</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Must compute migration rates first.&#39;</span><span class="p">)</span>
            <span class="k">return</span>
<span class="c1">#            elif hasattr(self, &#39;mr_zs_sm_nan&#39;):</span>
<span class="c1">#                migr_rate = self.mr_zs_sm_nan</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">migr_rate</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mr_zs_nan</span>

        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;cut_ids&#39;</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
            <span class="n">cutoff_inds</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">cutoff_inds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cut_ids</span>

        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;erode_ids&#39;</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
            <span class="n">erodibility_inds</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">erodibility_inds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">erode_ids</span>

        <span class="k">if</span> <span class="n">window</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;window_C&#39;</span><span class="p">):</span>
                <span class="n">window</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">window_C</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Must provide a smoothing window.&#39;</span><span class="p">)</span>
                <span class="k">return</span>

        <span class="n">LZC</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">infs_os</span>
        <span class="n">LZM</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ints</span>
        <span class="n">s</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">s</span><span class="p">()</span>
        <span class="n">curv</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Csmooth</span><span class="p">()</span>
        <span class="n">W</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">W</span>

        <span class="n">fig</span><span class="p">,</span> <span class="n">ax1</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">18</span><span class="p">,</span><span class="mi">4</span><span class="p">))</span>
<span class="c1">#            plt.tight_layout()</span>

        <span class="n">y1</span> <span class="o">=</span> <span class="mf">0.7</span>
        <span class="n">y2</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="n">y3</span> <span class="o">=</span> <span class="o">-</span><span class="mf">0.87</span>
        <span class="n">y4</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1.25</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">LZC</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">):</span>
            <span class="n">xcoords</span> <span class="o">=</span> <span class="p">[</span><span class="n">s</span><span class="p">[</span><span class="n">LZC</span><span class="p">[</span><span class="n">i</span><span class="p">]],</span><span class="n">s</span><span class="p">[</span><span class="n">LZC</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]],</span><span class="n">s</span><span class="p">[</span><span class="n">LZC</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]],</span><span class="n">s</span><span class="p">[</span><span class="n">LZM</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]],</span><span class="n">s</span><span class="p">[</span><span class="n">LZM</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]],</span><span class="n">s</span><span class="p">[</span><span class="n">LZM</span><span class="p">[</span><span class="n">i</span><span class="p">]],</span><span class="n">s</span><span class="p">[</span><span class="n">LZM</span><span class="p">[</span><span class="n">i</span><span class="p">]],</span><span class="n">s</span><span class="p">[</span><span class="n">LZC</span><span class="p">[</span><span class="n">i</span><span class="p">]]]</span>
            <span class="n">ycoords</span> <span class="o">=</span> <span class="p">[</span><span class="n">y1</span><span class="p">,</span><span class="n">y1</span><span class="p">,</span><span class="n">y2</span><span class="p">,</span><span class="n">y3</span><span class="p">,</span><span class="n">y4</span><span class="p">,</span><span class="n">y4</span><span class="p">,</span><span class="n">y3</span><span class="p">,</span><span class="n">y2</span><span class="p">]</span>
            <span class="n">ax1</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="n">xcoords</span><span class="p">,</span><span class="n">ycoords</span><span class="p">,</span><span class="n">color</span><span class="o">=</span><span class="p">[</span><span class="mf">0.85</span><span class="p">,</span><span class="mf">0.85</span><span class="p">,</span><span class="mf">0.85</span><span class="p">],</span><span class="n">zorder</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="n">ax1</span><span class="o">.</span><span class="n">fill_between</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">curv</span><span class="o">*</span><span class="n">W</span><span class="p">)</span>
        <span class="n">ax2</span> <span class="o">=</span> <span class="n">ax1</span><span class="o">.</span><span class="n">twinx</span><span class="p">()</span>
        <span class="n">ax2</span><span class="o">.</span><span class="n">fill_between</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">migr_rate</span><span class="p">,</span> <span class="n">facecolor</span><span class="o">=</span><span class="s1">&#39;green&#39;</span><span class="p">)</span>

        <span class="n">ax1</span><span class="o">.</span><span class="n">plot</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="nb">max</span><span class="p">(</span><span class="n">s</span><span class="p">)],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span><span class="s1">&#39;k--&#39;</span><span class="p">)</span>
        <span class="n">ax2</span><span class="o">.</span><span class="n">plot</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="nb">max</span><span class="p">(</span><span class="n">s</span><span class="p">)],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span><span class="s1">&#39;k--&#39;</span><span class="p">)</span>

        <span class="n">ax1</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">(</span><span class="n">y4</span><span class="p">,</span><span class="n">y1</span><span class="p">)</span>
        <span class="n">ax2</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">(</span><span class="o">-</span><span class="mi">15</span><span class="p">,</span><span class="mi">40</span><span class="p">)</span>
        <span class="n">ax1</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">LZC</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span><span class="n">s</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">erodibility_inds</span><span class="p">:</span>
            <span class="n">xcoords</span> <span class="o">=</span> <span class="p">[</span><span class="n">s</span><span class="p">[</span><span class="n">LZC</span><span class="p">[</span><span class="n">i</span><span class="p">]],</span><span class="n">s</span><span class="p">[</span><span class="n">LZC</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]],</span><span class="n">s</span><span class="p">[</span><span class="n">LZC</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]],</span><span class="n">s</span><span class="p">[</span><span class="n">LZM</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]],</span><span class="n">s</span><span class="p">[</span><span class="n">LZM</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]],</span><span class="n">s</span><span class="p">[</span><span class="n">LZM</span><span class="p">[</span><span class="n">i</span><span class="p">]],</span><span class="n">s</span><span class="p">[</span><span class="n">LZM</span><span class="p">[</span><span class="n">i</span><span class="p">]],</span><span class="n">s</span><span class="p">[</span><span class="n">LZC</span><span class="p">[</span><span class="n">i</span><span class="p">]]]</span>
            <span class="n">ycoords</span> <span class="o">=</span> <span class="p">[</span><span class="n">y1</span><span class="p">,</span><span class="n">y1</span><span class="p">,</span><span class="n">y2</span><span class="p">,</span><span class="n">y3</span><span class="p">,</span><span class="n">y4</span><span class="p">,</span><span class="n">y4</span><span class="p">,</span><span class="n">y3</span><span class="p">,</span><span class="n">y2</span><span class="p">]</span>
            <span class="n">ax1</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="n">xcoords</span><span class="p">,</span><span class="n">ycoords</span><span class="p">,</span><span class="n">color</span><span class="o">=</span><span class="p">[</span><span class="mf">1.0</span><span class="p">,</span><span class="mf">0.85</span><span class="p">,</span><span class="mf">0.85</span><span class="p">],</span><span class="n">zorder</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">cutoff_inds</span><span class="p">:</span>
            <span class="n">xcoords</span> <span class="o">=</span> <span class="p">[</span><span class="n">s</span><span class="p">[</span><span class="n">LZC</span><span class="p">[</span><span class="n">i</span><span class="p">]],</span><span class="n">s</span><span class="p">[</span><span class="n">LZC</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]],</span><span class="n">s</span><span class="p">[</span><span class="n">LZC</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]],</span><span class="n">s</span><span class="p">[</span><span class="n">LZM</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]],</span><span class="n">s</span><span class="p">[</span><span class="n">LZM</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]],</span><span class="n">s</span><span class="p">[</span><span class="n">LZM</span><span class="p">[</span><span class="n">i</span><span class="p">]],</span><span class="n">s</span><span class="p">[</span><span class="n">LZM</span><span class="p">[</span><span class="n">i</span><span class="p">]],</span><span class="n">s</span><span class="p">[</span><span class="n">LZC</span><span class="p">[</span><span class="n">i</span><span class="p">]]]</span>
            <span class="n">ycoords</span> <span class="o">=</span> <span class="p">[</span><span class="n">y1</span><span class="p">,</span><span class="n">y1</span><span class="p">,</span><span class="n">y2</span><span class="p">,</span><span class="n">y3</span><span class="p">,</span><span class="n">y4</span><span class="p">,</span><span class="n">y4</span><span class="p">,</span><span class="n">y3</span><span class="p">,</span><span class="n">y2</span><span class="p">]</span>
            <span class="n">ax1</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="n">xcoords</span><span class="p">,</span><span class="n">ycoords</span><span class="p">,</span><span class="n">color</span><span class="o">=</span><span class="p">[</span><span class="mf">0.85</span><span class="p">,</span><span class="mf">1.0</span><span class="p">,</span><span class="mf">0.85</span><span class="p">],</span><span class="n">zorder</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">LZC</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">migr_rate</span><span class="p">[</span><span class="n">LZM</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span><span class="n">LZM</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]]))</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
                <span class="n">xcoords</span> <span class="o">=</span> <span class="p">[</span><span class="n">s</span><span class="p">[</span><span class="n">LZC</span><span class="p">[</span><span class="n">i</span><span class="p">]],</span><span class="n">s</span><span class="p">[</span><span class="n">LZC</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]],</span><span class="n">s</span><span class="p">[</span><span class="n">LZC</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]],</span><span class="n">s</span><span class="p">[</span><span class="n">LZM</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]],</span><span class="n">s</span><span class="p">[</span><span class="n">LZM</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]],</span><span class="n">s</span><span class="p">[</span><span class="n">LZM</span><span class="p">[</span><span class="n">i</span><span class="p">]],</span><span class="n">s</span><span class="p">[</span><span class="n">LZM</span><span class="p">[</span><span class="n">i</span><span class="p">]],</span><span class="n">s</span><span class="p">[</span><span class="n">LZC</span><span class="p">[</span><span class="n">i</span><span class="p">]]]</span>
                <span class="n">ycoords</span> <span class="o">=</span> <span class="p">[</span><span class="n">y1</span><span class="p">,</span><span class="n">y1</span><span class="p">,</span><span class="n">y2</span><span class="p">,</span><span class="n">y3</span><span class="p">,</span><span class="n">y4</span><span class="p">,</span><span class="n">y4</span><span class="p">,</span><span class="n">y3</span><span class="p">,</span><span class="n">y2</span><span class="p">]</span>
                <span class="n">ax1</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="n">xcoords</span><span class="p">,</span><span class="n">ycoords</span><span class="p">,</span><span class="n">color</span><span class="o">=</span><span class="s1">&#39;w&#39;</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">LZC</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">migr_rate</span><span class="p">[</span><span class="n">LZM</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span><span class="n">LZM</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]]))</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
                <span class="n">xcoords</span> <span class="o">=</span> <span class="p">[</span><span class="n">s</span><span class="p">[</span><span class="n">LZC</span><span class="p">[</span><span class="n">i</span><span class="p">]],</span><span class="n">s</span><span class="p">[</span><span class="n">LZC</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]],</span><span class="n">s</span><span class="p">[</span><span class="n">LZC</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]],</span><span class="n">s</span><span class="p">[</span><span class="n">LZM</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]],</span><span class="n">s</span><span class="p">[</span><span class="n">LZM</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]],</span><span class="n">s</span><span class="p">[</span><span class="n">LZM</span><span class="p">[</span><span class="n">i</span><span class="p">]],</span><span class="n">s</span><span class="p">[</span><span class="n">LZM</span><span class="p">[</span><span class="n">i</span><span class="p">]],</span><span class="n">s</span><span class="p">[</span><span class="n">LZC</span><span class="p">[</span><span class="n">i</span><span class="p">]]]</span>
                <span class="n">ycoords</span> <span class="o">=</span> <span class="p">[</span><span class="mi">35</span><span class="p">,</span><span class="mi">35</span><span class="p">,</span><span class="mf">20.7145</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">15</span><span class="p">,</span><span class="o">-</span><span class="mi">15</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mf">20.7145</span><span class="p">]</span>
                <span class="n">ax2</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="n">xcoords</span><span class="p">,</span><span class="n">ycoords</span><span class="p">,</span><span class="n">color</span><span class="o">=</span><span class="s1">&#39;w&#39;</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">LZC</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">):</span>
            <span class="n">ax1</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">LZC</span><span class="p">[</span><span class="n">i</span><span class="p">]],</span><span class="mf">0.5</span><span class="p">,</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">),</span><span class="n">fontsize</span><span class="o">=</span><span class="mi">12</span><span class="p">)</span>


<div class="viewcode-block" id="compute_eBI"><a class="viewcode-back" href="../../../apiref/rivers.html#rivgraph.rivers.river_utils.compute_eBI">[docs]</a><span class="k">def</span> <span class="nf">compute_eBI</span><span class="p">(</span><span class="n">path_meshlines</span><span class="p">,</span> <span class="n">path_links</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;local&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    method can be &#39;local&#39; or &#39;avg&#39;</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">meshline_gdf</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">read_file</span><span class="p">(</span><span class="n">path_meshlines</span><span class="p">)</span>
    <span class="n">links_gdf</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">read_file</span><span class="p">(</span><span class="n">path_links</span><span class="p">)</span>

    <span class="k">if</span> <span class="s1">&#39;wid_adj&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">links_gdf</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;Widths have not been appended to links yet; cannot compute eBI.&#39;</span><span class="p">)</span>

    <span class="n">inter</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">sjoin</span><span class="p">(</span><span class="n">meshline_gdf</span><span class="p">,</span> <span class="n">links_gdf</span><span class="p">,</span> <span class="n">op</span><span class="o">=</span><span class="s1">&#39;intersects&#39;</span><span class="p">)</span>

    <span class="c1"># Conver link widths to floats</span>
    <span class="n">widths</span> <span class="o">=</span> <span class="n">links_gdf</span><span class="o">.</span><span class="n">wid_adj</span><span class="o">.</span><span class="n">values</span>
    <span class="n">widths</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="nb">float</span><span class="p">(</span><span class="n">w</span><span class="p">)</span> <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">widths</span><span class="p">])</span>

    <span class="c1"># Compute entropic braided index</span>
    <span class="n">mesh_index</span> <span class="o">=</span> <span class="n">meshline_gdf</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">values</span>
    <span class="n">eBI</span> <span class="o">=</span> <span class="p">[]</span> <span class="c1"># entropic braided index</span>
    <span class="n">BI</span> <span class="o">=</span> <span class="p">[]</span> <span class="c1"># braided index</span>
    <span class="k">for</span> <span class="n">mi</span> <span class="ow">in</span> <span class="n">mesh_index</span><span class="p">:</span> <span class="c1">#1585</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">mi</span><span class="p">)</span>
        <span class="c1"># if mi == 1584:</span>
        <span class="c1">#     import pdb; pdb.set_trace()</span>
        <span class="c1"># First see if the mesh intersects the centerline</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">int_links</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">inter</span><span class="p">[</span><span class="s1">&#39;index_right&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">inter</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">get_loc</span><span class="p">(</span><span class="n">mi</span><span class="p">)])</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="n">eBI</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">BI</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="k">continue</span>

        <span class="c1"># A second check to handle strange cases</span>
        <span class="n">bi_section</span> <span class="o">=</span> <span class="n">int_links</span><span class="o">.</span><span class="n">size</span>
        <span class="k">if</span> <span class="n">bi_section</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">eBI</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">BI</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="k">continue</span>

        <span class="c1"># This is because numpy returns an array when multiple values returned, and an int when a single value is returned</span>
        <span class="k">if</span> <span class="n">int_links</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">int_links</span> <span class="o">=</span> <span class="p">[</span><span class="n">int_links</span><span class="o">.</span><span class="n">tolist</span><span class="p">()]</span>

        <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;avg&#39;</span><span class="p">:</span>
            <span class="c1"># Method 1: use the average link width</span>
            <span class="n">ws</span> <span class="o">=</span> <span class="n">widths</span><span class="p">[</span><span class="n">int_links</span><span class="p">]</span>

        <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;local&#39;</span><span class="p">:</span>

            <span class="c1"># Method 2: use the local channel width</span>
            <span class="n">ws</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">il</span> <span class="ow">in</span> <span class="n">int_links</span><span class="p">:</span>
                <span class="c1"># print(links_gdf.id.values[il])</span>
                <span class="n">meshline</span> <span class="o">=</span> <span class="n">meshline_gdf</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">mi</span><span class="p">]</span>
                <span class="n">rivline</span> <span class="o">=</span> <span class="n">links_gdf</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">il</span><span class="p">]</span>
                <span class="n">int_pt</span> <span class="o">=</span> <span class="n">rivline</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">meshline</span><span class="p">)</span>

                <span class="c1"># If there are multiple intersection points along the same link, use the link&#39;s average width</span>
                <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">int_pt</span><span class="p">)</span> <span class="o">!=</span> <span class="n">shapely</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">point</span><span class="o">.</span><span class="n">Point</span><span class="p">:</span>
                    <span class="n">ws</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">widths</span><span class="p">[</span><span class="n">il</span><span class="p">])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">int_id</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">rivline</span><span class="o">.</span><span class="n">coords</span><span class="o">.</span><span class="n">xy</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">-</span><span class="n">int_pt</span><span class="o">.</span><span class="n">coords</span><span class="o">.</span><span class="n">xy</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">rivline</span><span class="o">.</span><span class="n">coords</span><span class="o">.</span><span class="n">xy</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">-</span><span class="n">int_pt</span><span class="o">.</span><span class="n">coords</span><span class="o">.</span><span class="n">xy</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span>

                    <span class="c1"># Converting from string to float</span>
                    <span class="n">ws_il</span> <span class="o">=</span> <span class="n">links_gdf</span><span class="o">.</span><span class="n">wid_pix</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">il</span><span class="p">]</span>
                    <span class="n">ws_il</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="nb">float</span><span class="p">(</span><span class="n">w</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;,&#39;</span><span class="p">,</span><span class="s1">&#39;&#39;</span><span class="p">))</span> <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">ws_il</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="p">)</span> <span class="k">if</span> <span class="n">w</span> <span class="o">!=</span> <span class="s1">&#39;&#39;</span><span class="p">])</span>
                    <span class="n">ws</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ws_il</span><span class="p">[</span><span class="n">int_id</span><span class="p">])</span>

        <span class="n">ws</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">w</span> <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">ws</span> <span class="k">if</span> <span class="n">w</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">])</span> <span class="c1"># Remove links of 0 width -- should determine why these are zero, probably due to computing widths on the original mask instead of the pre-processed one...</span>
        <span class="n">probs</span> <span class="o">=</span> <span class="n">ws</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">ws</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">probs</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;Transect </span><span class="si">{}</span><span class="s1"> intersects a link of width 0.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">mi</span><span class="p">))</span>

        <span class="n">H</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">probs</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">log2</span><span class="p">(</span><span class="n">probs</span><span class="p">))</span>
        <span class="n">ebi_section</span> <span class="o">=</span> <span class="mi">2</span><span class="o">**</span><span class="n">H</span>
        <span class="n">eBI</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ebi_section</span><span class="p">)</span>
        <span class="n">BI</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">bi_section</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">eBI</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">BI</span><span class="p">)</span></div>
</pre></div>

           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        
        &copy; Copyright 2020, J. Schwenk &amp; J. Hariharan

    </p>
  </div>
    
    
    
    Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>